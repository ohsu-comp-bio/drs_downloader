{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"DRS Downloader A file download tool for AnVIL/TDR data identified by DRS URIs Installation Checksum Verification Running the Executable Requirements Authentication Usage Quick Start Arguments Basic Example Example with a Different Header Value Help/Additional Options Credits Installation Operating System DRS Downloader Checksum macOS drs-downloader-macOS checksums.txt Linux drs-downloader-Linux checksums.txt Windows drs-downloader-Windows.exe checksums.txt Download the latest drs_downloader zip file for your operating system. Unzipping the downloaded file will provide a drs_downloader executable file that can be run directly. Supported OS Versions | Operating System | Supported Versions | | ---------------- | ------------------------------ | | macOS | 12 (Monterey), 13 (Ventura) | | Linux | Ubuntu 22.04 (Jammy Jellyfish) | | Windows | Windows 11 | _Notes_: - Testing was done on hardware running macOS Monterey and Ventura (Apple Silicon M1 chips), with Windows and Linux emulation through [UTM](https://mac.getutm.app/). - Due to hardware limitations with the ARM M1 chips, Windows 10 was not included in the list of tested operated systems as Microsoft does not currently provide a public Windows 10 ARM build. - Ubuntu 20.04 (Focal Fossa) uses version 2.31 of the GNU C Library which appears to be incompatible with Python 3.10 requirement of version 2.35. Checksum Verification In order to verify that the downloaded file can be trusted checksums are provided in checksums.txt . See below for examples of how to use this file. Successful Verification To verify the integrity of the binaries on macOS run the following command in the same directory as the downloaded file: $ shasum -c checksums.txt --ignore-missing drs-downloader-macOS: OK If the `shasum` command outputs `OK` than the verification was successful and the executable can be trusted. Unsuccessful Verification Alternatively if the commad outputs `FAILED` than the checksum did not match and the binary should not be run. $ shasum -c checksums.txt --ignore-missing drs-downloader-macOS: FAILED shasum: WARNING: 1 computed checksum did NOT match shasum: checksums.txt: no file was verified In such a case please reach out to the contributors for assistance. Running the Executable For Linux to run the exe you will have to grant the file higher permissions. you can do this by running: chmod +x [filename] For mac you will also have to navigate to: System Preferences -> Security & Privacy -> Click button allow Exe to run Requirements The downloader requires that a Google Cloud project be designated as the billing project. In order for the downloader to authenticate and set the desired billing project the gcloud CLI tool must first be installed: gcloud CLI \u2014 used to authenticate the downloader and set the billing project. Python \u2014 required for gcloud CLI functionality. Authentication Upon running the following gcloud command a browser window will open in which you may choose the Google account used for the billing project: $ gcloud auth application-default login Your browser has been opened to visit: https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=... You are now logged in as [rosalind@ohsu.edu]. Your current project is [terra-314159]. You can change this setting by running: $ gcloud config set project PROJECT_ID To change the billing project at any time you may use either the $ gcloud config set project PROJECT_ID command or the built-in drs-downloader command: $ drs_downloader terra --project-id Project ID> Usage Quick Start $ drs_downloader terra -m <manifest file> -d <destination directory> Arguments -s, --silent Disables all output to the terminal during and after downloading. -d, --destination_dir TEXT The directory or folder to download the DRS Objects to. Defaults to /tmp/testing if no value is provided. -m, --manifest_path TEXT The manifest file that contains the DRS Objects to be downloaded. Typically a TSV file with one row per DRS Object. --drs_header TEXT The value of the column in the manifest file containing the DRS Object IDs. Defaults to pfb:ga4gh_drs_uri if no value is provided. --duplicate downloads files and saves them into the specified directory even if there is already files with the same name already in the directory. Numbered naming is used to specify the order of duplicates downloaded to the directory. For example: 1st -> original_file 2nd -> original_file(1) 3rd-> original_file(2) ... Basic Example The below command is a basic example of how to structure a download command with all of the required arguments. It uses: a manifest file called terra-data.tsv with 10 DRS Objects a DRS header value of pfb:ga4gh_drs_uri within the manifest file to reference the DRS Objects. It can be omitted since this is the default value used by the downloader. a download directory called DATA as the destination $ drs_downloader terra -m tests/fixtures/manifest/terra-data.tsv -d DATA 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 56148.65it/s] 2022-11-21 16:56:49,595 ('HG03873.final.cram.crai', 'OK', 1351946, 1) 2022-11-21 16:56:49,595 ('HG04209.final.cram.crai', 'OK', 1338980, 1) 2022-11-21 16:56:49,595 ('HG02142.final.cram.crai', 'OK', 1405543, 1) 2022-11-21 16:56:49,595 ('HG01552.final.cram.crai', 'OK', 1296198, 1) 2022-11-21 16:56:49,595 ('NA18613.final.cram.crai', 'OK', 1370106, 1) 2022-11-21 16:56:49,595 ('HG00536.final.cram.crai', 'OK', 1244278, 1) 2022-11-21 16:56:49,595 ('HG02450.final.cram.crai', 'OK', 1405458, 1) 2022-11-21 16:56:49,595 ('NA20525.final.cram.crai', 'OK', 1337382, 1) 2022-11-21 16:56:49,595 ('NA20356.final.cram.crai', 'OK', 1368064, 1) 2022-11-21 16:56:49,595 ('HG00622.final.cram.crai', 'OK', 1254920, 1) 2022-11-21 16:56:49,595 ('done', 'statistics.max_files_open', 37) After the download completes we can look in the DATA directory to confirm that all 10 DRS Objects have been downloaded: $ ls ./DATA HG00536.final.cram.crai HG01552.final.cram.crai HG02450.final.cram.crai HG04209.final.cram.crai NA20356.final.cram.crai HG00622.final.cram.crai HG02142.final.cram.crai HG03873.final.cram.crai NA18613.final.cram.crai NA20525.final.cram.crai Example with a Different Header Value Let's take a look at different manifest file called terra-different-header.tsv . Namely the DRS header value is now drs_uri so we will need to tell the downloader which column to find the DRS URI's in the manifest with the --drs_header flag: drs_downloader terra -m tests/fixtures/manifests/terra-different-header.tsv -d DATA --drs_header drs_uri This will download the DRS Objects specified in the drs_uri column into the DATA directory just as before. Help/Additional Options To see all available flags run the help command: $ drs_downloader terra --help Usage: drs_download terra [OPTIONS] Copy files from terra.bio Options: -s, --silent Display nothing. -d, --destination_dir TEXT Destination directory. [default: /tmp/testing] -m, --manifest_path TEXT Path to manifest tsv. --duplicate allow duplicate downloads with same file name --drs_header TEXT The column header in the TSV file associated with the DRS URIs.Example: pfb:ga4gh_drs_uri --help Show this message and exit. Credits This project is developed in partnership between The AnVIL Project, the Broad Institute, and the Ellrott Lab at Oregon Health & Science University. Development is lead by Brian Walsh with contributions from Matthew Peterkort and Liam Beckman . Special thanks to Michael Baumann at the Broad Institute for guidance and development recommendations.","title":"DRS Downloader <!-- omit from toc -->"},{"location":"index.html#drs-downloader","text":"A file download tool for AnVIL/TDR data identified by DRS URIs Installation Checksum Verification Running the Executable Requirements Authentication Usage Quick Start Arguments Basic Example Example with a Different Header Value Help/Additional Options Credits","title":"DRS Downloader "},{"location":"index.html#installation","text":"Operating System DRS Downloader Checksum macOS drs-downloader-macOS checksums.txt Linux drs-downloader-Linux checksums.txt Windows drs-downloader-Windows.exe checksums.txt Download the latest drs_downloader zip file for your operating system. Unzipping the downloaded file will provide a drs_downloader executable file that can be run directly. Supported OS Versions | Operating System | Supported Versions | | ---------------- | ------------------------------ | | macOS | 12 (Monterey), 13 (Ventura) | | Linux | Ubuntu 22.04 (Jammy Jellyfish) | | Windows | Windows 11 | _Notes_: - Testing was done on hardware running macOS Monterey and Ventura (Apple Silicon M1 chips), with Windows and Linux emulation through [UTM](https://mac.getutm.app/). - Due to hardware limitations with the ARM M1 chips, Windows 10 was not included in the list of tested operated systems as Microsoft does not currently provide a public Windows 10 ARM build. - Ubuntu 20.04 (Focal Fossa) uses version 2.31 of the GNU C Library which appears to be incompatible with Python 3.10 requirement of version 2.35.","title":"Installation"},{"location":"index.html#checksum-verification","text":"In order to verify that the downloaded file can be trusted checksums are provided in checksums.txt . See below for examples of how to use this file. Successful Verification To verify the integrity of the binaries on macOS run the following command in the same directory as the downloaded file: $ shasum -c checksums.txt --ignore-missing drs-downloader-macOS: OK If the `shasum` command outputs `OK` than the verification was successful and the executable can be trusted. Unsuccessful Verification Alternatively if the commad outputs `FAILED` than the checksum did not match and the binary should not be run. $ shasum -c checksums.txt --ignore-missing drs-downloader-macOS: FAILED shasum: WARNING: 1 computed checksum did NOT match shasum: checksums.txt: no file was verified In such a case please reach out to the contributors for assistance.","title":"Checksum Verification"},{"location":"index.html#running-the-executable","text":"For Linux to run the exe you will have to grant the file higher permissions. you can do this by running: chmod +x [filename] For mac you will also have to navigate to: System Preferences -> Security & Privacy -> Click button allow Exe to run","title":"Running the Executable"},{"location":"index.html#requirements","text":"The downloader requires that a Google Cloud project be designated as the billing project. In order for the downloader to authenticate and set the desired billing project the gcloud CLI tool must first be installed: gcloud CLI \u2014 used to authenticate the downloader and set the billing project. Python \u2014 required for gcloud CLI functionality.","title":"Requirements"},{"location":"index.html#authentication","text":"Upon running the following gcloud command a browser window will open in which you may choose the Google account used for the billing project: $ gcloud auth application-default login Your browser has been opened to visit: https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=... You are now logged in as [rosalind@ohsu.edu]. Your current project is [terra-314159]. You can change this setting by running: $ gcloud config set project PROJECT_ID To change the billing project at any time you may use either the $ gcloud config set project PROJECT_ID command or the built-in drs-downloader command: $ drs_downloader terra --project-id Project ID>","title":"Authentication"},{"location":"index.html#usage","text":"","title":"Usage"},{"location":"index.html#quick-start","text":"$ drs_downloader terra -m <manifest file> -d <destination directory>","title":"Quick Start"},{"location":"index.html#arguments","text":"-s, --silent Disables all output to the terminal during and after downloading. -d, --destination_dir TEXT The directory or folder to download the DRS Objects to. Defaults to /tmp/testing if no value is provided. -m, --manifest_path TEXT The manifest file that contains the DRS Objects to be downloaded. Typically a TSV file with one row per DRS Object. --drs_header TEXT The value of the column in the manifest file containing the DRS Object IDs. Defaults to pfb:ga4gh_drs_uri if no value is provided. --duplicate downloads files and saves them into the specified directory even if there is already files with the same name already in the directory. Numbered naming is used to specify the order of duplicates downloaded to the directory. For example: 1st -> original_file 2nd -> original_file(1) 3rd-> original_file(2) ...","title":"Arguments"},{"location":"index.html#basic-example","text":"The below command is a basic example of how to structure a download command with all of the required arguments. It uses: a manifest file called terra-data.tsv with 10 DRS Objects a DRS header value of pfb:ga4gh_drs_uri within the manifest file to reference the DRS Objects. It can be omitted since this is the default value used by the downloader. a download directory called DATA as the destination $ drs_downloader terra -m tests/fixtures/manifest/terra-data.tsv -d DATA 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 56148.65it/s] 2022-11-21 16:56:49,595 ('HG03873.final.cram.crai', 'OK', 1351946, 1) 2022-11-21 16:56:49,595 ('HG04209.final.cram.crai', 'OK', 1338980, 1) 2022-11-21 16:56:49,595 ('HG02142.final.cram.crai', 'OK', 1405543, 1) 2022-11-21 16:56:49,595 ('HG01552.final.cram.crai', 'OK', 1296198, 1) 2022-11-21 16:56:49,595 ('NA18613.final.cram.crai', 'OK', 1370106, 1) 2022-11-21 16:56:49,595 ('HG00536.final.cram.crai', 'OK', 1244278, 1) 2022-11-21 16:56:49,595 ('HG02450.final.cram.crai', 'OK', 1405458, 1) 2022-11-21 16:56:49,595 ('NA20525.final.cram.crai', 'OK', 1337382, 1) 2022-11-21 16:56:49,595 ('NA20356.final.cram.crai', 'OK', 1368064, 1) 2022-11-21 16:56:49,595 ('HG00622.final.cram.crai', 'OK', 1254920, 1) 2022-11-21 16:56:49,595 ('done', 'statistics.max_files_open', 37) After the download completes we can look in the DATA directory to confirm that all 10 DRS Objects have been downloaded: $ ls ./DATA HG00536.final.cram.crai HG01552.final.cram.crai HG02450.final.cram.crai HG04209.final.cram.crai NA20356.final.cram.crai HG00622.final.cram.crai HG02142.final.cram.crai HG03873.final.cram.crai NA18613.final.cram.crai NA20525.final.cram.crai","title":"Basic Example"},{"location":"index.html#example-with-a-different-header-value","text":"Let's take a look at different manifest file called terra-different-header.tsv . Namely the DRS header value is now drs_uri so we will need to tell the downloader which column to find the DRS URI's in the manifest with the --drs_header flag: drs_downloader terra -m tests/fixtures/manifests/terra-different-header.tsv -d DATA --drs_header drs_uri This will download the DRS Objects specified in the drs_uri column into the DATA directory just as before.","title":"Example with a Different Header Value"},{"location":"index.html#helpadditional-options","text":"To see all available flags run the help command: $ drs_downloader terra --help Usage: drs_download terra [OPTIONS] Copy files from terra.bio Options: -s, --silent Display nothing. -d, --destination_dir TEXT Destination directory. [default: /tmp/testing] -m, --manifest_path TEXT Path to manifest tsv. --duplicate allow duplicate downloads with same file name --drs_header TEXT The column header in the TSV file associated with the DRS URIs.Example: pfb:ga4gh_drs_uri --help Show this message and exit.","title":"Help/Additional Options"},{"location":"index.html#credits","text":"This project is developed in partnership between The AnVIL Project, the Broad Institute, and the Ellrott Lab at Oregon Health & Science University. Development is lead by Brian Walsh with contributions from Matthew Peterkort and Liam Beckman . Special thanks to Michael Baumann at the Broad Institute for guidance and development recommendations.","title":"Credits"},{"location":"development.html","text":"Development To get ready for development first get the code: $ git clone https://github.com/anvilproject/drs_downloader $ cd drs_downloader Then create and activate a virtual environment using Python3.10 : $ python3.10 -m venv venv $ . venv/bin/activate $ pip install -r requirements.txt -r requirements-dev.txt Terra Authentication In order for the downloader to work, you will need to install Google gcloud CLI on your local machine. https://cloud.google.com/sdk/docs/install Next, you must connect the google account that your Terra account connected to gcloud. This is done with gcloud auth login: $ gcloud auth login You need to have a terra project that is set up for billing. Once you get one, go to your terra workspaces page: https://anvil.terra.bio/#workspaces/ Click on the project that you want to bill to. On the righthand corner of the screen click on Cloud Information heading. Copy and paste the Google Project Id field into the below command: $ gcloud config set project <project ID> Next, you need to link your Google account to the location where the DRS URIs will download from. This is endpoint specific. Go to anvil.terra.bio profile page If you are logging into bio data catalyst do the following: Right click on the log in/renew button. Select copy url. Copy this link in another tab but instead of pressing enter go to the end of the URL that was copied and change the suffix of the URL from =[old suffix] to =google If your URIs are not from bio data catalyst then authenticate with your Terra Linked Google account on the other sites. Now run gcloud auth print-access-token . This should return a long string of letters an numbers. If it doesn't then your Terra google account is probably not linked with your gcloud account. To test that this setup returns signed URLs copy and paste the below curl command into your terminal, but instead of running it replace [URI] with a DRS uri that belongs to a small file from your TSV file. By running this in terminal you should get back a signed URL that you can copy and paste into your browser to download a file. $ curl --request POST --url https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3 --header \"authorization: Bearer $(gcloud auth print-access-token)\" --header 'content-type: application/json' --data '{ \"url\": \"[URI]\", \"fields\": [\"fileName\", \"size\", \"hashes\", \"accessUrl\"] }' If you can run the above command with your own DRS URI than you are setup to run the command line tool. Now you should be ready to start coding and testing! Gen3 Authentication Tests All tests and test files are stored in the tests directory. Pytest is used as the testing framework. To run all tests with a coverage report run pytest with the --cov=tests flag: $ pytest --cov=tests ========================= test session starts ========================= platform darwin -- Python 3.9.4, pytest-7.2.0, pluggy-1.0.0 rootdir: /Users/beckmanl/code/drs_downloader, configfile: pyproject.toml plugins: cov-4.0.0, anyio-3.6.2 collected 4 items tests/unit/test_main.py ... [ 75%] tests/unit/test_basic_cli.py . [100%] ---------- coverage: platform darwin, python 3.9.4-final-0 ----------- Name Stmts Miss Cover -------------------------------------------------- tests/unit/test_main.py 41 0 100% tests/unit/test_basic_cli.py 3 0 100% -------------------------------------------------- TOTAL 44 0 100% ========================== 4 passed in 14.68s ========================== Contributing Pull requests, issues, and feature requests welcome. Please reach out if you have questions setting the development environment! Project layout \u250c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 index.md # The documentation homepage \u2502 \u2514\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 drs_downloader # Source directory \u2502 \u251c\u2500\u2500 clients \u2502 \u251c\u2500\u2500 manager.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 requirements-dev.txt # Installation dependencies \u251c\u2500\u2500 requirements.txt # Development dependencies \u251c\u2500\u2500 setup.py # Setuptools file, used by Pyinstaller and pip \u2514\u2500\u2500 tests \u251c\u2500\u2500 fixtures # Test manifest files \u2514\u2500\u2500 unit # Unit tests Useful Packages Here are a few packages we've found useful for this project: Pip Packages - pipdeptree - Flake8 - autopep8 Git Extensions - pre-commit - git-secrets VS Code Extensions - autoDocstring - Markdown All in One - Python","title":"Development"},{"location":"development.html#development","text":"To get ready for development first get the code: $ git clone https://github.com/anvilproject/drs_downloader $ cd drs_downloader Then create and activate a virtual environment using Python3.10 : $ python3.10 -m venv venv $ . venv/bin/activate $ pip install -r requirements.txt -r requirements-dev.txt","title":"Development"},{"location":"development.html#terra-authentication","text":"In order for the downloader to work, you will need to install Google gcloud CLI on your local machine. https://cloud.google.com/sdk/docs/install Next, you must connect the google account that your Terra account connected to gcloud. This is done with gcloud auth login: $ gcloud auth login You need to have a terra project that is set up for billing. Once you get one, go to your terra workspaces page: https://anvil.terra.bio/#workspaces/ Click on the project that you want to bill to. On the righthand corner of the screen click on Cloud Information heading. Copy and paste the Google Project Id field into the below command: $ gcloud config set project <project ID> Next, you need to link your Google account to the location where the DRS URIs will download from. This is endpoint specific. Go to anvil.terra.bio profile page If you are logging into bio data catalyst do the following: Right click on the log in/renew button. Select copy url. Copy this link in another tab but instead of pressing enter go to the end of the URL that was copied and change the suffix of the URL from =[old suffix] to =google If your URIs are not from bio data catalyst then authenticate with your Terra Linked Google account on the other sites. Now run gcloud auth print-access-token . This should return a long string of letters an numbers. If it doesn't then your Terra google account is probably not linked with your gcloud account. To test that this setup returns signed URLs copy and paste the below curl command into your terminal, but instead of running it replace [URI] with a DRS uri that belongs to a small file from your TSV file. By running this in terminal you should get back a signed URL that you can copy and paste into your browser to download a file. $ curl --request POST --url https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3 --header \"authorization: Bearer $(gcloud auth print-access-token)\" --header 'content-type: application/json' --data '{ \"url\": \"[URI]\", \"fields\": [\"fileName\", \"size\", \"hashes\", \"accessUrl\"] }' If you can run the above command with your own DRS URI than you are setup to run the command line tool. Now you should be ready to start coding and testing!","title":"Terra Authentication"},{"location":"development.html#gen3-authentication","text":"","title":"Gen3 Authentication"},{"location":"development.html#tests","text":"All tests and test files are stored in the tests directory. Pytest is used as the testing framework. To run all tests with a coverage report run pytest with the --cov=tests flag: $ pytest --cov=tests ========================= test session starts ========================= platform darwin -- Python 3.9.4, pytest-7.2.0, pluggy-1.0.0 rootdir: /Users/beckmanl/code/drs_downloader, configfile: pyproject.toml plugins: cov-4.0.0, anyio-3.6.2 collected 4 items tests/unit/test_main.py ... [ 75%] tests/unit/test_basic_cli.py . [100%] ---------- coverage: platform darwin, python 3.9.4-final-0 ----------- Name Stmts Miss Cover -------------------------------------------------- tests/unit/test_main.py 41 0 100% tests/unit/test_basic_cli.py 3 0 100% -------------------------------------------------- TOTAL 44 0 100% ========================== 4 passed in 14.68s ==========================","title":"Tests"},{"location":"development.html#contributing","text":"Pull requests, issues, and feature requests welcome. Please reach out if you have questions setting the development environment!","title":"Contributing"},{"location":"development.html#project-layout","text":"\u250c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 index.md # The documentation homepage \u2502 \u2514\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 drs_downloader # Source directory \u2502 \u251c\u2500\u2500 clients \u2502 \u251c\u2500\u2500 manager.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 requirements-dev.txt # Installation dependencies \u251c\u2500\u2500 requirements.txt # Development dependencies \u251c\u2500\u2500 setup.py # Setuptools file, used by Pyinstaller and pip \u2514\u2500\u2500 tests \u251c\u2500\u2500 fixtures # Test manifest files \u2514\u2500\u2500 unit # Unit tests","title":"Project layout"},{"location":"development.html#useful-packages","text":"Here are a few packages we've found useful for this project: Pip Packages - pipdeptree - Flake8 - autopep8 Git Extensions - pre-commit - git-secrets VS Code Extensions - autoDocstring - Markdown All in One - Python","title":"Useful Packages"},{"location":"testing.html","text":"Testing Instructions Thank you for trying out the DRS Downloader! This project was developed by our team of developers here at OHSU and the Broad Institute for use in The AnVIL ecosystem. We are excited to hear any feedback or suggestions based off of your experience with it! Let's get started. Installation First navigate to the documentation page here and select the \"drs_downloader\" link for your operating system. You may also choose to download the checksums file in order to verify the file integrity (instructions on how to do so may be found here ). We'll be using this manifest file for the downloading, but feel free to substitute it for any valid manifest file as well. The one we link to includes a variety of file types and sizes to test against our program. With the drs_downloader program and manifest file in place we're now ready to authenticate with Google. In order to do so we'll use the the gcloud CLI program provided by Google. Instructions for the installation of gcloud may be found here and are replicated below: - Download the tar.gz archive for your OS - Extract the archive to your home directory - Run the install script with ./google-cloud-sdk/install.sh - Log in with the Google account you want to use for billing with gcloud auth application-default login . This will open a browser window with a Google login prompt. Use Now that we've successfully authenticated with Google we're ready to start the downloading! Verify that the DRS downloader is ready to use by entering drs_downloader terra --help . This should output all available flags and options for the terra download function. Now let's start the download process! We'll specify our manifest file and the destination we wish to download to, in this the /tmp directory: drs_downloader terra --manifest_path terra-data.tsv --destination_dir /tmp This command will output the progress of the download process. Upon completion we can verify that the files were successfully downloaded by looking at the destination directory.","title":"Testing Instructions"},{"location":"testing.html#testing-instructions","text":"Thank you for trying out the DRS Downloader! This project was developed by our team of developers here at OHSU and the Broad Institute for use in The AnVIL ecosystem. We are excited to hear any feedback or suggestions based off of your experience with it! Let's get started.","title":"Testing Instructions"},{"location":"testing.html#installation","text":"First navigate to the documentation page here and select the \"drs_downloader\" link for your operating system. You may also choose to download the checksums file in order to verify the file integrity (instructions on how to do so may be found here ). We'll be using this manifest file for the downloading, but feel free to substitute it for any valid manifest file as well. The one we link to includes a variety of file types and sizes to test against our program. With the drs_downloader program and manifest file in place we're now ready to authenticate with Google. In order to do so we'll use the the gcloud CLI program provided by Google. Instructions for the installation of gcloud may be found here and are replicated below: - Download the tar.gz archive for your OS - Extract the archive to your home directory - Run the install script with ./google-cloud-sdk/install.sh - Log in with the Google account you want to use for billing with gcloud auth application-default login . This will open a browser window with a Google login prompt.","title":"Installation"},{"location":"testing.html#use","text":"Now that we've successfully authenticated with Google we're ready to start the downloading! Verify that the DRS downloader is ready to use by entering drs_downloader terra --help . This should output all available flags and options for the terra download function. Now let's start the download process! We'll specify our manifest file and the destination we wish to download to, in this the /tmp directory: drs_downloader terra --manifest_path terra-data.tsv --destination_dir /tmp This command will output the progress of the download process. Upon completion we can verify that the files were successfully downloaded by looking at the destination directory.","title":"Use"},{"location":"reference/index.html","text":"Main module for the DRS downloader package. Configuration options allow for optimizing the download process: Object retrievers: The number of DRS objects are retrieved in a given batch. Object signers: The number of DRS objects signed in a given batch. Downloaders: The number of simultaneous downloads to start in a given batch. Part handlers: The number of parts to download at a given time. Part size: size in bytes for each downloadable part of a given DRS object.","title":"drs_downloader"},{"location":"reference/SUMMARY.html","text":"drs_downloader cli clients gen3 mock terra manager models upgrader","title":"SUMMARY"},{"location":"reference/cli.html","text":"cli () Copy DRS objects from the cloud to your local system . Source code in drs_downloader/cli.py 26 27 28 29 @click . group () def cli (): \"\"\"Copy DRS objects from the cloud to your local system .\"\"\" pass gen3 ( verbose , destination_dir , manifest_path , drs_column_name , api_key_path , endpoint , duplicate ) Copy files from gen3 server. Source code in drs_downloader/cli.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = \"ga4gh_drs_uri\" , show_default = True , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--api-key-path\" , show_default = True , help = \"Gen3 credentials file\" ) @click . option ( \"--endpoint\" , show_default = True , required = True , help = \"Gen3 endpoint\" ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def gen3 ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , api_key_path : str , endpoint : str , duplicate : bool , ): \"\"\"Copy files from gen3 server.\"\"\" # read from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) _perform_downloads ( destination_dir , Gen3DrsClient ( api_key_path = api_key_path , endpoint = endpoint ), ids_from_manifest , verbose , duplicate = duplicate , ) mock ( verbose , destination_dir , manifest_path , drs_column_name , duplicate ) Generate test files locally, without the need for server. Source code in drs_downloader/cli.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = \"ga4gh_drs_uri\" , show_default = True , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def mock ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , duplicate : bool , ): \"\"\"Generate test files locally, without the need for server.\"\"\" # # get ids from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) # perform downloads with a mock drs client _perform_downloads ( destination_dir , MockDrsClient (), ids_from_manifest , verbose , duplicate = duplicate ) pretty_size ( bytes ) Integer -> human readable Data Size Pretty Printer Source code in drs_downloader/cli.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def pretty_size ( bytes ): \"\"\"Integer -> human readable Data Size Pretty Printer\"\"\" assert ( bytes and bytes > 0 ), f \"ERROR, The total download size { bytes } is Zero or None\" units = [ ( 1 << 50 , \" PB\" ), ( 1 << 40 , \" TB\" ), ( 1 << 30 , \" GB\" ), ( 1 << 20 , \" MB\" ), ( 1 << 10 , \" KB\" ), ( 1 , ( \" bytes\" )), ] if ( bytes / 1000000000 < 1 ): price = 0.1 else : price = ' %.2f ' % (( bytes / 1000000000 ) * 0.1 ) for factor , suffix in units : if bytes >= factor : break amount = int ( bytes / factor ) return str ( amount ) + suffix , price terra ( verbose , destination_dir , manifest_path , drs_column_name , duplicate ) Copy files from terra.bio Source code in drs_downloader/cli.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = None , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def terra ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , duplicate : bool , ): \"\"\"Copy files from terra.bio\"\"\" # get ids from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) # perform downloads with a terra drs client _perform_downloads ( destination_dir , TerraDrsClient (), ids_from_manifest = ids_from_manifest , verbose = verbose , duplicate = duplicate , )","title":"cli"},{"location":"reference/cli.html#drs_downloader.cli.cli","text":"Copy DRS objects from the cloud to your local system . Source code in drs_downloader/cli.py 26 27 28 29 @click . group () def cli (): \"\"\"Copy DRS objects from the cloud to your local system .\"\"\" pass","title":"cli()"},{"location":"reference/cli.html#drs_downloader.cli.gen3","text":"Copy files from gen3 server. Source code in drs_downloader/cli.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = \"ga4gh_drs_uri\" , show_default = True , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--api-key-path\" , show_default = True , help = \"Gen3 credentials file\" ) @click . option ( \"--endpoint\" , show_default = True , required = True , help = \"Gen3 endpoint\" ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def gen3 ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , api_key_path : str , endpoint : str , duplicate : bool , ): \"\"\"Copy files from gen3 server.\"\"\" # read from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) _perform_downloads ( destination_dir , Gen3DrsClient ( api_key_path = api_key_path , endpoint = endpoint ), ids_from_manifest , verbose , duplicate = duplicate , )","title":"gen3()"},{"location":"reference/cli.html#drs_downloader.cli.mock","text":"Generate test files locally, without the need for server. Source code in drs_downloader/cli.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = \"ga4gh_drs_uri\" , show_default = True , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def mock ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , duplicate : bool , ): \"\"\"Generate test files locally, without the need for server.\"\"\" # # get ids from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) # perform downloads with a mock drs client _perform_downloads ( destination_dir , MockDrsClient (), ids_from_manifest , verbose , duplicate = duplicate )","title":"mock()"},{"location":"reference/cli.html#drs_downloader.cli.pretty_size","text":"Integer -> human readable Data Size Pretty Printer Source code in drs_downloader/cli.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def pretty_size ( bytes ): \"\"\"Integer -> human readable Data Size Pretty Printer\"\"\" assert ( bytes and bytes > 0 ), f \"ERROR, The total download size { bytes } is Zero or None\" units = [ ( 1 << 50 , \" PB\" ), ( 1 << 40 , \" TB\" ), ( 1 << 30 , \" GB\" ), ( 1 << 20 , \" MB\" ), ( 1 << 10 , \" KB\" ), ( 1 , ( \" bytes\" )), ] if ( bytes / 1000000000 < 1 ): price = 0.1 else : price = ' %.2f ' % (( bytes / 1000000000 ) * 0.1 ) for factor , suffix in units : if bytes >= factor : break amount = int ( bytes / factor ) return str ( amount ) + suffix , price","title":"pretty_size()"},{"location":"reference/cli.html#drs_downloader.cli.terra","text":"Copy files from terra.bio Source code in drs_downloader/cli.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @cli . command () @click . option ( \"--verbose\" , \"-v\" , is_flag = True , show_default = True , default = False , help = \"Display every logger\" , ) @click . option ( \"--destination-dir\" , \"-d\" , show_default = True , default = os . getcwd (), help = \"Destination directory.\" , ) @click . option ( \"--manifest-path\" , \"-m\" , show_default = True , help = \"Path to manifest tsv.\" ) @click . option ( \"--drs-column-name\" , default = None , help = \"The column header in the TSV file associated with the DRS URIs.\" \"Example: pfb:ga4gh_drs_uri\" , ) @click . option ( \"--duplicate\" , default = False , is_flag = True , show_default = True , help = \"This flag is used to specify wether \\ or not to download the file again if it already exists in the directory\" \"Example: True\" , ) def terra ( verbose : bool , destination_dir : str , manifest_path : str , drs_column_name : str , duplicate : bool , ): \"\"\"Copy files from terra.bio\"\"\" # get ids from manifest ids_from_manifest = _extract_tsv_info ( Path ( manifest_path ), drs_column_name ) # perform downloads with a terra drs client _perform_downloads ( destination_dir , TerraDrsClient (), ids_from_manifest = ids_from_manifest , verbose = verbose , duplicate = duplicate , )","title":"terra()"},{"location":"reference/manager.html","text":"DrsAsyncManager Bases: DrsManager Manage DRSClient workload with asyncio threads, display progress. Source code in drs_downloader/manager.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 class DrsAsyncManager ( DrsManager ): \"\"\"Manage DRSClient workload with asyncio threads, display progress.\"\"\" def __init__ ( self , drs_client : DrsClient , show_progress : bool = True , part_size : int = DEFAULT_PART_SIZE , max_simultaneous_object_retrievers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS , max_simultaneous_downloaders = DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS , max_simultaneous_part_handlers = DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS , max_simultaneous_object_signers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS , ): \"\"\" Args: drs_client: the client that will interact with server show_progress: show progress bars part_size: tweak to optimize workload max_simultaneous_object_retrievers: tweak to optimize workload max_simultaneous_downloaders: tweak to optimize workload max_simultaneous_part_handlers: tweak to optimize workload \"\"\" # \"\"\"Implements abstract constructor.\"\"\" super () . __init__ ( drs_client = drs_client ) self . max_simultaneous_object_retrievers = max_simultaneous_object_retrievers self . max_simultaneous_object_signers = max_simultaneous_object_signers self . max_simultaneous_downloaders = max_simultaneous_downloaders self . max_simultaneous_part_handlers = max_simultaneous_part_handlers self . disable = not show_progress self . part_size = part_size @staticmethod def _parts_generator ( size : int , start : int = 0 , part_size : int = None ) -> Iterator [ Tuple [ int , int ]]: \"\"\"Determine the start,size for each part Args: size: size of file start: offset into file 0 based part_size: desired part size Returns: iterator of tuple start, size \"\"\" while size - start > part_size : yield start , start + part_size start += part_size + 1 # start += part_size yield start , size async def wait_till_completed ( self , tasks , err_function_msg ): drs_objects_with_signed_urls = [] while tasks : done , tasks = await asyncio . wait ( tasks , return_when = asyncio . FIRST_EXCEPTION ) for t in tqdm . tqdm ( done , total = len ( tasks ), desc = f \"retrieving { err_function_msg } information\" , disable = self . disable ): try : y = await t drs_objects_with_signed_urls . append ( y ) except Exception : signed_url = DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"Exception in { err_function_msg } function\" ], ) drs_objects_with_signed_urls . append ( signed_url ) t . cancel () return drs_objects_with_signed_urls async def _run_download_parts ( self , drs_object : DrsObject , destination_path : Path , verbose : bool ) -> DrsObject : \"\"\"Determine number of parts for signed url and create tasks for each part, run them in batches. Args: drs_object: Information about a bucket object Returns: list of paths to files for each part, in order. \"\"\" # create a list of parts parts = [] for start , size in self . _parts_generator ( size = drs_object . size , part_size = self . part_size ): parts . append ( ( start , size , ) ) if len ( parts ) > 1000 : if verbose : logger . warning ( f 'Warning: tasks > 1000 { drs_object . name } has over 1000 parts and is a large download. \\ ( { len ( parts ) } )' ) if drs_object . size > 20 * MB : self . disable = False else : self . disable = True paths = [] # TODO - tqdm ugly here? for chunk_parts in tqdm . tqdm ( DrsAsyncManager . chunker ( parts , self . max_simultaneous_part_handlers ), total = math . ceil ( len ( parts ) / self . max_simultaneous_part_handlers ), desc = \"File Download Progress\" , file = sys . stdout , leave = False , disable = self . disable , ): chunk_tasks = [] existing_chunks = [] for start , size in chunk_parts : # Check if part file exists and if so verify the expected size. # If size matches the expected value then return the Path of the file_name for eventual reassembly. # If size does not match then attempt to restart the download. file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" file_path = Path ( file_name ) if self . check_existing_parts ( file_path , start , size , verbose ): existing_chunks . append ( file_path ) continue task = asyncio . create_task ( self . _drs_client . download_part ( drs_object = drs_object , start = start , size = size , destination_path = destination_path , verbose = verbose ) ) chunk_tasks . append ( task ) chunk_paths = await self . wait_till_completed ( chunk_tasks , \"download_parts\" ) \"\"\" Uncessesary logging message for the end user. When you take into account that most downloads are going to take longer than 15 minutes and this message will be spammed for every part that is already downlaoded when the resigning step happens. if len(existing_chunks) > 0: #logger.info(f\"{drs_object.name} had {len(existing_chunks)} existing parts.\") \"\"\" chunk_paths . extend ( existing_chunks ) # something bad happened if None in chunk_paths : if any ( [ \"RECOVERABLE in AIOHTTP\" in str ( error ) for error in drs_object . errors ] ): return drs_object else : if verbose : logger . error ( f \" { drs_object . name } had missing part.\" ) return drs_object paths . extend ( chunk_paths ) \"\"\" print(\" LIST OF DRS OBJECT ERRORS AFTER DLOAD IN RUN DOWNLOAD PARTS\",drs_object.errors) print(\"RECOVERABLE? \",any(['RECOVERABLE' in str(error) for error in drs_object.errors])) if(any(['RECOVERABLE' in str(error) for error in drs_object.errors])): return drs_object \"\"\" if ( None not in chunk_paths and len ( existing_chunks ) == 0 and self . disable is True ): if verbose : logger . info ( \" %s Downloaded sucessfully\" , drs_object . name ) drs_object . file_parts = paths i = 1 filename = ( f \" { drs_object . name } \" or drs_object . access_methods [ 0 ] . access_url . split ( \"/\" )[ - 1 ] . split ( \"?\" )[ 0 ] ) original_file_name = Path ( filename ) while True : if os . path . isfile ( destination_path . joinpath ( filename )): filename = f \" { original_file_name } ( { i } )\" i = i + 1 continue break # re-assemble and test the file parts # hash function dynamic checksum_type = drs_object . checksums [ 0 ] . type assert ( checksum_type in hashlib . algorithms_available ), f \"Checksum { checksum_type } not supported.\" checksum = hashlib . new ( checksum_type ) with open ( destination_path . joinpath ( filename ), \"wb\" ) as wfd : # sort the items of the list in place - Numerically based on start i.e. \"xxxxxx.start.end.part\" drs_object . file_parts . sort ( key = lambda x : int ( str ( x ) . split ( \".\" )[ - 3 ])) T_0 = time . time () for f in tqdm . tqdm ( drs_object . file_parts , total = len ( drs_object . file_parts ), desc = f \" { drs_object . name : 50.50 } stitching\" , file = sys . stdout , leave = False , disable = self . disable , ): fd = open ( f , \"rb\" ) # NOT ASYNC wrapped_fd = Wrapped ( fd , checksum ) # efficient way to write await asyncio . to_thread ( shutil . copyfileobj , wrapped_fd , wfd , 1024 * 1024 * 10 ) # explicitly close all wrapped_fd . close () f . unlink () fd . close () wfd . flush () T_FIN = time . time () if verbose : logger . info ( f \"TOTAL 'STITCHING' (md5 10*MB no flush) TIME { T_FIN - T_0 } { original_file_name } \" ) actual_checksum = checksum . hexdigest () actual_size = os . stat ( Path ( destination_path . joinpath ( filename ))) . st_size # compare calculated md5 vs expected expected_checksum = drs_object . checksums [ 0 ] . checksum if expected_checksum != actual_checksum : msg = f \"Actual { checksum_type } hash { actual_checksum } does not match expected { expected_checksum } \" if verbose : logger . error ( f \"Actual { checksum_type } hash { actual_checksum } \\ does not match expected { expected_checksum } \" ) drs_object . errors . append ( msg ) if drs_object . size != actual_size : msg = f \"The actual size { actual_size } does not match expected size { drs_object . size } \" drs_object . errors . append ( msg ) # parts will be purposefully saved if there is an error so that # recovery script can have a chance to rebuild the file return drs_object async def _run_download ( self , drs_objects : List [ DrsObject ], destination_path : Path , verbose : bool ) -> List [ DrsObject ]: \"\"\" Create tasks to sign and download, display progress. Args: drs_objects: list of drs objects to download Returns: updated list of drs objects \"\"\" # first sign the urls tasks = [] for drs_object in drs_objects : if len ( drs_object . errors ) == 0 : task = asyncio . create_task ( self . _drs_client . sign_url ( drs_object = drs_object , verbose = verbose )) tasks . append ( task ) drs_objects_with_signed_urls = await self . wait_till_completed ( tasks , \"sign_url\" ) tasks = [] for drs_object in drs_objects_with_signed_urls : if len ( drs_object . errors ) == 0 : task = asyncio . create_task ( self . _run_download_parts ( drs_object = drs_object , destination_path = destination_path , verbose = verbose ) ) tasks . append ( task ) else : logger . error ( f \" { drs_object . id } has error { drs_object . errors } , not attempting anything further\" ) drs_objects_with_file_parts = await self . wait_till_completed ( tasks , \"run_download_parts\" ) return drs_objects_with_file_parts async def _run_get_objects ( self , object_ids : List [ str ], leave : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Create async tasks to retrieve list DrsObject, displays progress. Args: object_ids: object_id from manifest leave: leave flag to keep progress indicator displayed Returns: \"\"\" tasks = [] for object_id in object_ids : task = asyncio . create_task ( self . _drs_client . get_object ( object_id = object_id , verbose = verbose )) tasks . append ( task ) object_information = [] object_information = await self . wait_till_completed ( tasks , \"get_object\" ) return object_information @classmethod def chunker ( cls , seq : Collection , size : int ) -> Iterator : \"\"\"Iterate over a list in chunks. Args: seq: an iterable size: desired chunk size Returns: an iterator that returns lists of size or less \"\"\" return ( seq [ pos : pos + size ] for pos in range ( 0 , len ( seq ), size )) def get_objects ( self , object_ids : List [ str ], verbose : bool ) -> List [ DrsObject ]: \"\"\"Create tasks for all object_ids, run them in batches, get information about the object. Args: object_ids: list of objects to fetch \"\"\" drs_objects = [] total_batches = math . ceil ( len ( object_ids ) / self . max_simultaneous_object_retrievers ) # rounding # this would imply that if batch count is 9.3, and you round down the last .3 is never # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all current = 0 for chunk_of_object_ids in DrsAsyncManager . chunker ( object_ids , self . max_simultaneous_object_retrievers ): drs_objects . extend ( asyncio . run ( self . _run_get_objects ( object_ids = chunk_of_object_ids , leave = ( current == total_batches ), verbose = verbose ) ) ) current += 1 return drs_objects def download ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable sizes, download the files. Args: drs_objects: list of DrsObject destination_path: directory where to write files when complete Returns: DrsObjects updated with _file_parts \"\"\" while True : filtered_objects = self . filter_existing_files ( drs_objects , destination_path , duplicate = duplicate , verbose = verbose ) if len ( filtered_objects ) < len ( drs_objects ): complete_objects = [ obj for obj in drs_objects if obj not in filtered_objects ] for obj in complete_objects : if verbose : logger . info ( f \" { obj . name } already exists in { destination_path } . Skipping download.\" ) if len ( filtered_objects ) == 0 : logger . info ( f \"All DRS objects already present in { destination_path } .\" ) return current = 0 updated_drs_objects = [] for chunk_of_drs_objects in DrsAsyncManager . chunker ( filtered_objects , self . max_simultaneous_object_retrievers ): completed_chunk = asyncio . run ( self . _run_download ( drs_objects = chunk_of_drs_objects , destination_path = destination_path , verbose = verbose ) ) current += 1 updated_drs_objects . extend ( completed_chunk ) if verbose : logger . info ( f \"UPDATED DRS OBJECTS \\n\\n { updated_drs_objects } \" ) if \"RECOVERABLE in AIOHTTP\" not in str ( updated_drs_objects ): break else : if verbose : logger . info ( \"RECURSING \\n\\n\\n \" ) for drsobject in drs_objects : drsobject . errors . clear () return updated_drs_objects def optimize_workload ( self , verbose , drs_objects : List [ DrsObject ] ) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: same list that was passed \"\"\" # Now that we have the objects to download, we have an opportunity to shape the downloads # e.g. are the smallest files first? tweak MAX_* to optimize per workload # TODO: If part sizes changed here, would this result in an error in test recovery? # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case # there is a pytest written for them that will fail otherwise if len ( drs_objects ) == 1 : self . max_simultaneous_part_handlers = 50 self . part_size = 64 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif any ( True for drs_object in drs_objects if ( int ( drs_object . size ) > GB )): self . max_simultaneous_part_handlers = 3 self . part_size = 128 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif all (( drs_object . size < ( 5 * MB )) for drs_object in drs_objects ): self . part_size = 1 * MB self . max_simultaneous_part_handlers = 2 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) else : self . part_size = 128 * MB self . max_simultaneous_part_handlers = 10 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) return drs_objects def filter_existing_files ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory. Args: drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded) destination_path (Path): Download destination that may contain partially downloaded files Returns: List[DrsObject]: The DRS objects that have yet to be downloaded \"\"\" if verbose : logger . info ( f \"VALUE OF duplicate { duplicate } \" ) if duplicate is True : return drs_objects # Testing File filtering by size also \"\"\" for drs in drs_objects: logger.info(f\"drs.size: {drs.size} != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\") if(drs.size != os.path.getsize(drs.name)): logger.warning(f\"{drs.name} is the wrong size, consider running this command again with the --duplicate flag so that your current file with the same name is not overwritten by this one that is on the path to downloading\") \"\"\" filtered_objects = [ drs for drs in drs_objects if ( drs . name not in os . listdir ( destination_path )) # or drs.size != os.path.getsize(drs.name) <-- this is used for filtering out wrong sized stuff ] if verbose : logger . info ( f \"VALUE OF FILTERED OBJECTS { filtered_objects } \" ) return filtered_objects def check_existing_parts ( self , file_path : Path , start : int , size : int , verbose : bool ) -> bool : \"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Args: file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) start (int): Beginning byte of the file part (ex. 1048577) size (int): Final byte of the file part (ex. 1244278) Returns: bool: True if the file part exists in the destination and has the expected file size, False otherwise \"\"\" if file_path . exists (): expected_size = size - start + 1 if verbose : logger . info ( f \"EXPTECTED PART SIZE SIZE { expected_size } \" ) actual_size = file_path . stat () . st_size sizes_match = actual_size == expected_size if verbose : logger . info ( f \"ACTUAL SIZE { actual_size } \" ) if sizes_match is True : # this logger message is really redundant when you are downloading large files. # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\") return True return False __init__ ( drs_client , show_progress = True , part_size = DEFAULT_PART_SIZE , max_simultaneous_object_retrievers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS , max_simultaneous_downloaders = DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS , max_simultaneous_part_handlers = DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS , max_simultaneous_object_signers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS ) Parameters: Name Type Description Default drs_client DrsClient the client that will interact with server required show_progress bool show progress bars True part_size int tweak to optimize workload DEFAULT_PART_SIZE max_simultaneous_object_retrievers tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS max_simultaneous_downloaders tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS max_simultaneous_part_handlers tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS Source code in drs_downloader/manager.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def __init__ ( self , drs_client : DrsClient , show_progress : bool = True , part_size : int = DEFAULT_PART_SIZE , max_simultaneous_object_retrievers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS , max_simultaneous_downloaders = DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS , max_simultaneous_part_handlers = DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS , max_simultaneous_object_signers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS , ): \"\"\" Args: drs_client: the client that will interact with server show_progress: show progress bars part_size: tweak to optimize workload max_simultaneous_object_retrievers: tweak to optimize workload max_simultaneous_downloaders: tweak to optimize workload max_simultaneous_part_handlers: tweak to optimize workload \"\"\" # \"\"\"Implements abstract constructor.\"\"\" super () . __init__ ( drs_client = drs_client ) self . max_simultaneous_object_retrievers = max_simultaneous_object_retrievers self . max_simultaneous_object_signers = max_simultaneous_object_signers self . max_simultaneous_downloaders = max_simultaneous_downloaders self . max_simultaneous_part_handlers = max_simultaneous_part_handlers self . disable = not show_progress self . part_size = part_size check_existing_parts ( file_path , start , size , verbose ) Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Parameters: Name Type Description Default file_path Path Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) required start int Beginning byte of the file part (ex. 1048577) required size int Final byte of the file part (ex. 1244278) required Returns: Name Type Description bool bool True if the file part exists in the destination and has the expected file size, False otherwise Source code in drs_downloader/manager.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def check_existing_parts ( self , file_path : Path , start : int , size : int , verbose : bool ) -> bool : \"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Args: file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) start (int): Beginning byte of the file part (ex. 1048577) size (int): Final byte of the file part (ex. 1244278) Returns: bool: True if the file part exists in the destination and has the expected file size, False otherwise \"\"\" if file_path . exists (): expected_size = size - start + 1 if verbose : logger . info ( f \"EXPTECTED PART SIZE SIZE { expected_size } \" ) actual_size = file_path . stat () . st_size sizes_match = actual_size == expected_size if verbose : logger . info ( f \"ACTUAL SIZE { actual_size } \" ) if sizes_match is True : # this logger message is really redundant when you are downloading large files. # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\") return True return False chunker ( seq , size ) classmethod Iterate over a list in chunks. Parameters: Name Type Description Default seq Collection an iterable required size int desired chunk size required Returns: Type Description Iterator an iterator that returns lists of size or less Source code in drs_downloader/manager.py 435 436 437 438 439 440 441 442 443 444 445 446 @classmethod def chunker ( cls , seq : Collection , size : int ) -> Iterator : \"\"\"Iterate over a list in chunks. Args: seq: an iterable size: desired chunk size Returns: an iterator that returns lists of size or less \"\"\" return ( seq [ pos : pos + size ] for pos in range ( 0 , len ( seq ), size )) download ( drs_objects , destination_path , duplicate , verbose ) Split the drs_objects into manageable sizes, download the files. Parameters: Name Type Description Default drs_objects List [ DrsObject ] list of DrsObject required destination_path Path directory where to write files when complete required Returns: Type Description List [ DrsObject ] DrsObjects updated with _file_parts Source code in drs_downloader/manager.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def download ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable sizes, download the files. Args: drs_objects: list of DrsObject destination_path: directory where to write files when complete Returns: DrsObjects updated with _file_parts \"\"\" while True : filtered_objects = self . filter_existing_files ( drs_objects , destination_path , duplicate = duplicate , verbose = verbose ) if len ( filtered_objects ) < len ( drs_objects ): complete_objects = [ obj for obj in drs_objects if obj not in filtered_objects ] for obj in complete_objects : if verbose : logger . info ( f \" { obj . name } already exists in { destination_path } . Skipping download.\" ) if len ( filtered_objects ) == 0 : logger . info ( f \"All DRS objects already present in { destination_path } .\" ) return current = 0 updated_drs_objects = [] for chunk_of_drs_objects in DrsAsyncManager . chunker ( filtered_objects , self . max_simultaneous_object_retrievers ): completed_chunk = asyncio . run ( self . _run_download ( drs_objects = chunk_of_drs_objects , destination_path = destination_path , verbose = verbose ) ) current += 1 updated_drs_objects . extend ( completed_chunk ) if verbose : logger . info ( f \"UPDATED DRS OBJECTS \\n\\n { updated_drs_objects } \" ) if \"RECOVERABLE in AIOHTTP\" not in str ( updated_drs_objects ): break else : if verbose : logger . info ( \"RECURSING \\n\\n\\n \" ) for drsobject in drs_objects : drsobject . errors . clear () return updated_drs_objects filter_existing_files ( drs_objects , destination_path , duplicate , verbose ) Remove any DRS objects from a given list if they are already exist in the destination directory. Parameters: Name Type Description Default drs_objects List [ DrsObject ] The DRS objects from the manifest (some may already be downloaded) required destination_path Path Download destination that may contain partially downloaded files required Returns: Type Description List [ DrsObject ] List[DrsObject]: The DRS objects that have yet to be downloaded Source code in drs_downloader/manager.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def filter_existing_files ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory. Args: drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded) destination_path (Path): Download destination that may contain partially downloaded files Returns: List[DrsObject]: The DRS objects that have yet to be downloaded \"\"\" if verbose : logger . info ( f \"VALUE OF duplicate { duplicate } \" ) if duplicate is True : return drs_objects # Testing File filtering by size also \"\"\" for drs in drs_objects: logger.info(f\"drs.size: {drs.size} != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\") if(drs.size != os.path.getsize(drs.name)): logger.warning(f\"{drs.name} is the wrong size, consider running this command again with the --duplicate flag so that your current file with the same name is not overwritten by this one that is on the path to downloading\") \"\"\" filtered_objects = [ drs for drs in drs_objects if ( drs . name not in os . listdir ( destination_path )) # or drs.size != os.path.getsize(drs.name) <-- this is used for filtering out wrong sized stuff ] if verbose : logger . info ( f \"VALUE OF FILTERED OBJECTS { filtered_objects } \" ) return filtered_objects get_objects ( object_ids , verbose ) Create tasks for all object_ids, run them in batches, get information about the object. Parameters: Name Type Description Default object_ids List [ str ] list of objects to fetch required Source code in drs_downloader/manager.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def get_objects ( self , object_ids : List [ str ], verbose : bool ) -> List [ DrsObject ]: \"\"\"Create tasks for all object_ids, run them in batches, get information about the object. Args: object_ids: list of objects to fetch \"\"\" drs_objects = [] total_batches = math . ceil ( len ( object_ids ) / self . max_simultaneous_object_retrievers ) # rounding # this would imply that if batch count is 9.3, and you round down the last .3 is never # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all current = 0 for chunk_of_object_ids in DrsAsyncManager . chunker ( object_ids , self . max_simultaneous_object_retrievers ): drs_objects . extend ( asyncio . run ( self . _run_get_objects ( object_ids = chunk_of_object_ids , leave = ( current == total_batches ), verbose = verbose ) ) ) current += 1 return drs_objects optimize_workload ( verbose , drs_objects ) Optimize the workload, sort prioritize and set thread management parameters. Parameters: Name Type Description Default drs_objects List [ DrsObject ] required Returns: Type Description List [ DrsObject ] same list that was passed Source code in drs_downloader/manager.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 def optimize_workload ( self , verbose , drs_objects : List [ DrsObject ] ) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: same list that was passed \"\"\" # Now that we have the objects to download, we have an opportunity to shape the downloads # e.g. are the smallest files first? tweak MAX_* to optimize per workload # TODO: If part sizes changed here, would this result in an error in test recovery? # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case # there is a pytest written for them that will fail otherwise if len ( drs_objects ) == 1 : self . max_simultaneous_part_handlers = 50 self . part_size = 64 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif any ( True for drs_object in drs_objects if ( int ( drs_object . size ) > GB )): self . max_simultaneous_part_handlers = 3 self . part_size = 128 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif all (( drs_object . size < ( 5 * MB )) for drs_object in drs_objects ): self . part_size = 1 * MB self . max_simultaneous_part_handlers = 2 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) else : self . part_size = 128 * MB self . max_simultaneous_part_handlers = 10 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) return drs_objects DrsManager Bases: ABC Manage DRSClient workload. Source code in drs_downloader/manager.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class DrsManager ( ABC ): \"\"\"Manage DRSClient workload.\"\"\" @abstractmethod def __init__ ( self , drs_client : DrsClient ): self . _drs_client = drs_client @abstractmethod def get_objects ( self , object_ids : List [ str ]) -> List [ DrsObject ]: \"\"\"Fetch list of DRSObject from passed ids. Args: object_ids: list of objects to fetch \"\"\" pass @abstractmethod def download ( self , drs_objects : List [ DrsObject ], destination_path : Path ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable parts, download the files. Args: drs_objects: objects to download destination_path: directory where to write files when complete Returns: list of updated DrsObjects \"\"\" @abstractmethod async def optimize_workload ( self , drs_objects : List [ DrsObject ]) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: \"\"\" # TODO - now that we have the objects to download, we have an opportunity to shape the downloads # TODO - e.g. smallest files first? tweak MAX_* to optimize per workload return drs_objects download ( drs_objects , destination_path ) abstractmethod Split the drs_objects into manageable parts, download the files. Parameters: Name Type Description Default drs_objects List [ DrsObject ] objects to download required destination_path Path directory where to write files when complete required Returns: Type Description List [ DrsObject ] list of updated DrsObjects Source code in drs_downloader/manager.py 62 63 64 65 66 67 68 69 70 71 72 73 74 @abstractmethod def download ( self , drs_objects : List [ DrsObject ], destination_path : Path ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable parts, download the files. Args: drs_objects: objects to download destination_path: directory where to write files when complete Returns: list of updated DrsObjects \"\"\" get_objects ( object_ids ) abstractmethod Fetch list of DRSObject from passed ids. Parameters: Name Type Description Default object_ids List [ str ] list of objects to fetch required Source code in drs_downloader/manager.py 53 54 55 56 57 58 59 60 @abstractmethod def get_objects ( self , object_ids : List [ str ]) -> List [ DrsObject ]: \"\"\"Fetch list of DRSObject from passed ids. Args: object_ids: list of objects to fetch \"\"\" pass optimize_workload ( drs_objects ) async abstractmethod Optimize the workload, sort prioritize and set thread management parameters. Parameters: Name Type Description Default drs_objects List [ DrsObject ] required Source code in drs_downloader/manager.py 76 77 78 79 80 81 82 83 84 85 86 87 88 @abstractmethod async def optimize_workload ( self , drs_objects : List [ DrsObject ]) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: \"\"\" # TODO - now that we have the objects to download, we have an opportunity to shape the downloads # TODO - e.g. smallest files first? tweak MAX_* to optimize per workload return drs_objects Wrapped Bases: object Source code in drs_downloader/manager.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class Wrapped ( object ): def __init__ ( self , file , hash_method ): \"\"\" Wrap the read() method and calculate hash Args: file: destination file hash_method: instantiated hash_method \"\"\" self . _file = file self . _hash_method = hash_method def read ( self , size ): buffer = self . _file . read ( size ) self . _hash_method . update ( buffer ) return buffer def __getattr__ ( self , attr ): return getattr ( self . _file , attr ) __init__ ( file , hash_method ) Wrap the read() method and calculate hash Parameters: Name Type Description Default file destination file required hash_method instantiated hash_method required Source code in drs_downloader/manager.py 92 93 94 95 96 97 98 99 100 def __init__ ( self , file , hash_method ): \"\"\" Wrap the read() method and calculate hash Args: file: destination file hash_method: instantiated hash_method \"\"\" self . _file = file self . _hash_method = hash_method","title":"manager"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager","text":"Bases: DrsManager Manage DRSClient workload with asyncio threads, display progress. Source code in drs_downloader/manager.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 class DrsAsyncManager ( DrsManager ): \"\"\"Manage DRSClient workload with asyncio threads, display progress.\"\"\" def __init__ ( self , drs_client : DrsClient , show_progress : bool = True , part_size : int = DEFAULT_PART_SIZE , max_simultaneous_object_retrievers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS , max_simultaneous_downloaders = DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS , max_simultaneous_part_handlers = DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS , max_simultaneous_object_signers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS , ): \"\"\" Args: drs_client: the client that will interact with server show_progress: show progress bars part_size: tweak to optimize workload max_simultaneous_object_retrievers: tweak to optimize workload max_simultaneous_downloaders: tweak to optimize workload max_simultaneous_part_handlers: tweak to optimize workload \"\"\" # \"\"\"Implements abstract constructor.\"\"\" super () . __init__ ( drs_client = drs_client ) self . max_simultaneous_object_retrievers = max_simultaneous_object_retrievers self . max_simultaneous_object_signers = max_simultaneous_object_signers self . max_simultaneous_downloaders = max_simultaneous_downloaders self . max_simultaneous_part_handlers = max_simultaneous_part_handlers self . disable = not show_progress self . part_size = part_size @staticmethod def _parts_generator ( size : int , start : int = 0 , part_size : int = None ) -> Iterator [ Tuple [ int , int ]]: \"\"\"Determine the start,size for each part Args: size: size of file start: offset into file 0 based part_size: desired part size Returns: iterator of tuple start, size \"\"\" while size - start > part_size : yield start , start + part_size start += part_size + 1 # start += part_size yield start , size async def wait_till_completed ( self , tasks , err_function_msg ): drs_objects_with_signed_urls = [] while tasks : done , tasks = await asyncio . wait ( tasks , return_when = asyncio . FIRST_EXCEPTION ) for t in tqdm . tqdm ( done , total = len ( tasks ), desc = f \"retrieving { err_function_msg } information\" , disable = self . disable ): try : y = await t drs_objects_with_signed_urls . append ( y ) except Exception : signed_url = DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"Exception in { err_function_msg } function\" ], ) drs_objects_with_signed_urls . append ( signed_url ) t . cancel () return drs_objects_with_signed_urls async def _run_download_parts ( self , drs_object : DrsObject , destination_path : Path , verbose : bool ) -> DrsObject : \"\"\"Determine number of parts for signed url and create tasks for each part, run them in batches. Args: drs_object: Information about a bucket object Returns: list of paths to files for each part, in order. \"\"\" # create a list of parts parts = [] for start , size in self . _parts_generator ( size = drs_object . size , part_size = self . part_size ): parts . append ( ( start , size , ) ) if len ( parts ) > 1000 : if verbose : logger . warning ( f 'Warning: tasks > 1000 { drs_object . name } has over 1000 parts and is a large download. \\ ( { len ( parts ) } )' ) if drs_object . size > 20 * MB : self . disable = False else : self . disable = True paths = [] # TODO - tqdm ugly here? for chunk_parts in tqdm . tqdm ( DrsAsyncManager . chunker ( parts , self . max_simultaneous_part_handlers ), total = math . ceil ( len ( parts ) / self . max_simultaneous_part_handlers ), desc = \"File Download Progress\" , file = sys . stdout , leave = False , disable = self . disable , ): chunk_tasks = [] existing_chunks = [] for start , size in chunk_parts : # Check if part file exists and if so verify the expected size. # If size matches the expected value then return the Path of the file_name for eventual reassembly. # If size does not match then attempt to restart the download. file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" file_path = Path ( file_name ) if self . check_existing_parts ( file_path , start , size , verbose ): existing_chunks . append ( file_path ) continue task = asyncio . create_task ( self . _drs_client . download_part ( drs_object = drs_object , start = start , size = size , destination_path = destination_path , verbose = verbose ) ) chunk_tasks . append ( task ) chunk_paths = await self . wait_till_completed ( chunk_tasks , \"download_parts\" ) \"\"\" Uncessesary logging message for the end user. When you take into account that most downloads are going to take longer than 15 minutes and this message will be spammed for every part that is already downlaoded when the resigning step happens. if len(existing_chunks) > 0: #logger.info(f\"{drs_object.name} had {len(existing_chunks)} existing parts.\") \"\"\" chunk_paths . extend ( existing_chunks ) # something bad happened if None in chunk_paths : if any ( [ \"RECOVERABLE in AIOHTTP\" in str ( error ) for error in drs_object . errors ] ): return drs_object else : if verbose : logger . error ( f \" { drs_object . name } had missing part.\" ) return drs_object paths . extend ( chunk_paths ) \"\"\" print(\" LIST OF DRS OBJECT ERRORS AFTER DLOAD IN RUN DOWNLOAD PARTS\",drs_object.errors) print(\"RECOVERABLE? \",any(['RECOVERABLE' in str(error) for error in drs_object.errors])) if(any(['RECOVERABLE' in str(error) for error in drs_object.errors])): return drs_object \"\"\" if ( None not in chunk_paths and len ( existing_chunks ) == 0 and self . disable is True ): if verbose : logger . info ( \" %s Downloaded sucessfully\" , drs_object . name ) drs_object . file_parts = paths i = 1 filename = ( f \" { drs_object . name } \" or drs_object . access_methods [ 0 ] . access_url . split ( \"/\" )[ - 1 ] . split ( \"?\" )[ 0 ] ) original_file_name = Path ( filename ) while True : if os . path . isfile ( destination_path . joinpath ( filename )): filename = f \" { original_file_name } ( { i } )\" i = i + 1 continue break # re-assemble and test the file parts # hash function dynamic checksum_type = drs_object . checksums [ 0 ] . type assert ( checksum_type in hashlib . algorithms_available ), f \"Checksum { checksum_type } not supported.\" checksum = hashlib . new ( checksum_type ) with open ( destination_path . joinpath ( filename ), \"wb\" ) as wfd : # sort the items of the list in place - Numerically based on start i.e. \"xxxxxx.start.end.part\" drs_object . file_parts . sort ( key = lambda x : int ( str ( x ) . split ( \".\" )[ - 3 ])) T_0 = time . time () for f in tqdm . tqdm ( drs_object . file_parts , total = len ( drs_object . file_parts ), desc = f \" { drs_object . name : 50.50 } stitching\" , file = sys . stdout , leave = False , disable = self . disable , ): fd = open ( f , \"rb\" ) # NOT ASYNC wrapped_fd = Wrapped ( fd , checksum ) # efficient way to write await asyncio . to_thread ( shutil . copyfileobj , wrapped_fd , wfd , 1024 * 1024 * 10 ) # explicitly close all wrapped_fd . close () f . unlink () fd . close () wfd . flush () T_FIN = time . time () if verbose : logger . info ( f \"TOTAL 'STITCHING' (md5 10*MB no flush) TIME { T_FIN - T_0 } { original_file_name } \" ) actual_checksum = checksum . hexdigest () actual_size = os . stat ( Path ( destination_path . joinpath ( filename ))) . st_size # compare calculated md5 vs expected expected_checksum = drs_object . checksums [ 0 ] . checksum if expected_checksum != actual_checksum : msg = f \"Actual { checksum_type } hash { actual_checksum } does not match expected { expected_checksum } \" if verbose : logger . error ( f \"Actual { checksum_type } hash { actual_checksum } \\ does not match expected { expected_checksum } \" ) drs_object . errors . append ( msg ) if drs_object . size != actual_size : msg = f \"The actual size { actual_size } does not match expected size { drs_object . size } \" drs_object . errors . append ( msg ) # parts will be purposefully saved if there is an error so that # recovery script can have a chance to rebuild the file return drs_object async def _run_download ( self , drs_objects : List [ DrsObject ], destination_path : Path , verbose : bool ) -> List [ DrsObject ]: \"\"\" Create tasks to sign and download, display progress. Args: drs_objects: list of drs objects to download Returns: updated list of drs objects \"\"\" # first sign the urls tasks = [] for drs_object in drs_objects : if len ( drs_object . errors ) == 0 : task = asyncio . create_task ( self . _drs_client . sign_url ( drs_object = drs_object , verbose = verbose )) tasks . append ( task ) drs_objects_with_signed_urls = await self . wait_till_completed ( tasks , \"sign_url\" ) tasks = [] for drs_object in drs_objects_with_signed_urls : if len ( drs_object . errors ) == 0 : task = asyncio . create_task ( self . _run_download_parts ( drs_object = drs_object , destination_path = destination_path , verbose = verbose ) ) tasks . append ( task ) else : logger . error ( f \" { drs_object . id } has error { drs_object . errors } , not attempting anything further\" ) drs_objects_with_file_parts = await self . wait_till_completed ( tasks , \"run_download_parts\" ) return drs_objects_with_file_parts async def _run_get_objects ( self , object_ids : List [ str ], leave : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Create async tasks to retrieve list DrsObject, displays progress. Args: object_ids: object_id from manifest leave: leave flag to keep progress indicator displayed Returns: \"\"\" tasks = [] for object_id in object_ids : task = asyncio . create_task ( self . _drs_client . get_object ( object_id = object_id , verbose = verbose )) tasks . append ( task ) object_information = [] object_information = await self . wait_till_completed ( tasks , \"get_object\" ) return object_information @classmethod def chunker ( cls , seq : Collection , size : int ) -> Iterator : \"\"\"Iterate over a list in chunks. Args: seq: an iterable size: desired chunk size Returns: an iterator that returns lists of size or less \"\"\" return ( seq [ pos : pos + size ] for pos in range ( 0 , len ( seq ), size )) def get_objects ( self , object_ids : List [ str ], verbose : bool ) -> List [ DrsObject ]: \"\"\"Create tasks for all object_ids, run them in batches, get information about the object. Args: object_ids: list of objects to fetch \"\"\" drs_objects = [] total_batches = math . ceil ( len ( object_ids ) / self . max_simultaneous_object_retrievers ) # rounding # this would imply that if batch count is 9.3, and you round down the last .3 is never # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all current = 0 for chunk_of_object_ids in DrsAsyncManager . chunker ( object_ids , self . max_simultaneous_object_retrievers ): drs_objects . extend ( asyncio . run ( self . _run_get_objects ( object_ids = chunk_of_object_ids , leave = ( current == total_batches ), verbose = verbose ) ) ) current += 1 return drs_objects def download ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable sizes, download the files. Args: drs_objects: list of DrsObject destination_path: directory where to write files when complete Returns: DrsObjects updated with _file_parts \"\"\" while True : filtered_objects = self . filter_existing_files ( drs_objects , destination_path , duplicate = duplicate , verbose = verbose ) if len ( filtered_objects ) < len ( drs_objects ): complete_objects = [ obj for obj in drs_objects if obj not in filtered_objects ] for obj in complete_objects : if verbose : logger . info ( f \" { obj . name } already exists in { destination_path } . Skipping download.\" ) if len ( filtered_objects ) == 0 : logger . info ( f \"All DRS objects already present in { destination_path } .\" ) return current = 0 updated_drs_objects = [] for chunk_of_drs_objects in DrsAsyncManager . chunker ( filtered_objects , self . max_simultaneous_object_retrievers ): completed_chunk = asyncio . run ( self . _run_download ( drs_objects = chunk_of_drs_objects , destination_path = destination_path , verbose = verbose ) ) current += 1 updated_drs_objects . extend ( completed_chunk ) if verbose : logger . info ( f \"UPDATED DRS OBJECTS \\n\\n { updated_drs_objects } \" ) if \"RECOVERABLE in AIOHTTP\" not in str ( updated_drs_objects ): break else : if verbose : logger . info ( \"RECURSING \\n\\n\\n \" ) for drsobject in drs_objects : drsobject . errors . clear () return updated_drs_objects def optimize_workload ( self , verbose , drs_objects : List [ DrsObject ] ) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: same list that was passed \"\"\" # Now that we have the objects to download, we have an opportunity to shape the downloads # e.g. are the smallest files first? tweak MAX_* to optimize per workload # TODO: If part sizes changed here, would this result in an error in test recovery? # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case # there is a pytest written for them that will fail otherwise if len ( drs_objects ) == 1 : self . max_simultaneous_part_handlers = 50 self . part_size = 64 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif any ( True for drs_object in drs_objects if ( int ( drs_object . size ) > GB )): self . max_simultaneous_part_handlers = 3 self . part_size = 128 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif all (( drs_object . size < ( 5 * MB )) for drs_object in drs_objects ): self . part_size = 1 * MB self . max_simultaneous_part_handlers = 2 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) else : self . part_size = 128 * MB self . max_simultaneous_part_handlers = 10 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) return drs_objects def filter_existing_files ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory. Args: drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded) destination_path (Path): Download destination that may contain partially downloaded files Returns: List[DrsObject]: The DRS objects that have yet to be downloaded \"\"\" if verbose : logger . info ( f \"VALUE OF duplicate { duplicate } \" ) if duplicate is True : return drs_objects # Testing File filtering by size also \"\"\" for drs in drs_objects: logger.info(f\"drs.size: {drs.size} != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\") if(drs.size != os.path.getsize(drs.name)): logger.warning(f\"{drs.name} is the wrong size, consider running this command again with the --duplicate flag so that your current file with the same name is not overwritten by this one that is on the path to downloading\") \"\"\" filtered_objects = [ drs for drs in drs_objects if ( drs . name not in os . listdir ( destination_path )) # or drs.size != os.path.getsize(drs.name) <-- this is used for filtering out wrong sized stuff ] if verbose : logger . info ( f \"VALUE OF FILTERED OBJECTS { filtered_objects } \" ) return filtered_objects def check_existing_parts ( self , file_path : Path , start : int , size : int , verbose : bool ) -> bool : \"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Args: file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) start (int): Beginning byte of the file part (ex. 1048577) size (int): Final byte of the file part (ex. 1244278) Returns: bool: True if the file part exists in the destination and has the expected file size, False otherwise \"\"\" if file_path . exists (): expected_size = size - start + 1 if verbose : logger . info ( f \"EXPTECTED PART SIZE SIZE { expected_size } \" ) actual_size = file_path . stat () . st_size sizes_match = actual_size == expected_size if verbose : logger . info ( f \"ACTUAL SIZE { actual_size } \" ) if sizes_match is True : # this logger message is really redundant when you are downloading large files. # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\") return True return False","title":"DrsAsyncManager"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.__init__","text":"Parameters: Name Type Description Default drs_client DrsClient the client that will interact with server required show_progress bool show progress bars True part_size int tweak to optimize workload DEFAULT_PART_SIZE max_simultaneous_object_retrievers tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS max_simultaneous_downloaders tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS max_simultaneous_part_handlers tweak to optimize workload DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS Source code in drs_downloader/manager.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def __init__ ( self , drs_client : DrsClient , show_progress : bool = True , part_size : int = DEFAULT_PART_SIZE , max_simultaneous_object_retrievers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS , max_simultaneous_downloaders = DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS , max_simultaneous_part_handlers = DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS , max_simultaneous_object_signers = DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS , ): \"\"\" Args: drs_client: the client that will interact with server show_progress: show progress bars part_size: tweak to optimize workload max_simultaneous_object_retrievers: tweak to optimize workload max_simultaneous_downloaders: tweak to optimize workload max_simultaneous_part_handlers: tweak to optimize workload \"\"\" # \"\"\"Implements abstract constructor.\"\"\" super () . __init__ ( drs_client = drs_client ) self . max_simultaneous_object_retrievers = max_simultaneous_object_retrievers self . max_simultaneous_object_signers = max_simultaneous_object_signers self . max_simultaneous_downloaders = max_simultaneous_downloaders self . max_simultaneous_part_handlers = max_simultaneous_part_handlers self . disable = not show_progress self . part_size = part_size","title":"__init__()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.check_existing_parts","text":"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Parameters: Name Type Description Default file_path Path Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) required start int Beginning byte of the file part (ex. 1048577) required size int Final byte of the file part (ex. 1244278) required Returns: Name Type Description bool bool True if the file part exists in the destination and has the expected file size, False otherwise Source code in drs_downloader/manager.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def check_existing_parts ( self , file_path : Path , start : int , size : int , verbose : bool ) -> bool : \"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it prompts a new download process for that part. Args: file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part) start (int): Beginning byte of the file part (ex. 1048577) size (int): Final byte of the file part (ex. 1244278) Returns: bool: True if the file part exists in the destination and has the expected file size, False otherwise \"\"\" if file_path . exists (): expected_size = size - start + 1 if verbose : logger . info ( f \"EXPTECTED PART SIZE SIZE { expected_size } \" ) actual_size = file_path . stat () . st_size sizes_match = actual_size == expected_size if verbose : logger . info ( f \"ACTUAL SIZE { actual_size } \" ) if sizes_match is True : # this logger message is really redundant when you are downloading large files. # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\") return True return False","title":"check_existing_parts()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.chunker","text":"Iterate over a list in chunks. Parameters: Name Type Description Default seq Collection an iterable required size int desired chunk size required Returns: Type Description Iterator an iterator that returns lists of size or less Source code in drs_downloader/manager.py 435 436 437 438 439 440 441 442 443 444 445 446 @classmethod def chunker ( cls , seq : Collection , size : int ) -> Iterator : \"\"\"Iterate over a list in chunks. Args: seq: an iterable size: desired chunk size Returns: an iterator that returns lists of size or less \"\"\" return ( seq [ pos : pos + size ] for pos in range ( 0 , len ( seq ), size ))","title":"chunker()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.download","text":"Split the drs_objects into manageable sizes, download the files. Parameters: Name Type Description Default drs_objects List [ DrsObject ] list of DrsObject required destination_path Path directory where to write files when complete required Returns: Type Description List [ DrsObject ] DrsObjects updated with _file_parts Source code in drs_downloader/manager.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def download ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable sizes, download the files. Args: drs_objects: list of DrsObject destination_path: directory where to write files when complete Returns: DrsObjects updated with _file_parts \"\"\" while True : filtered_objects = self . filter_existing_files ( drs_objects , destination_path , duplicate = duplicate , verbose = verbose ) if len ( filtered_objects ) < len ( drs_objects ): complete_objects = [ obj for obj in drs_objects if obj not in filtered_objects ] for obj in complete_objects : if verbose : logger . info ( f \" { obj . name } already exists in { destination_path } . Skipping download.\" ) if len ( filtered_objects ) == 0 : logger . info ( f \"All DRS objects already present in { destination_path } .\" ) return current = 0 updated_drs_objects = [] for chunk_of_drs_objects in DrsAsyncManager . chunker ( filtered_objects , self . max_simultaneous_object_retrievers ): completed_chunk = asyncio . run ( self . _run_download ( drs_objects = chunk_of_drs_objects , destination_path = destination_path , verbose = verbose ) ) current += 1 updated_drs_objects . extend ( completed_chunk ) if verbose : logger . info ( f \"UPDATED DRS OBJECTS \\n\\n { updated_drs_objects } \" ) if \"RECOVERABLE in AIOHTTP\" not in str ( updated_drs_objects ): break else : if verbose : logger . info ( \"RECURSING \\n\\n\\n \" ) for drsobject in drs_objects : drsobject . errors . clear () return updated_drs_objects","title":"download()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.filter_existing_files","text":"Remove any DRS objects from a given list if they are already exist in the destination directory. Parameters: Name Type Description Default drs_objects List [ DrsObject ] The DRS objects from the manifest (some may already be downloaded) required destination_path Path Download destination that may contain partially downloaded files required Returns: Type Description List [ DrsObject ] List[DrsObject]: The DRS objects that have yet to be downloaded Source code in drs_downloader/manager.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def filter_existing_files ( self , drs_objects : List [ DrsObject ], destination_path : Path , duplicate : bool , verbose : bool ) -> List [ DrsObject ]: \"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory. Args: drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded) destination_path (Path): Download destination that may contain partially downloaded files Returns: List[DrsObject]: The DRS objects that have yet to be downloaded \"\"\" if verbose : logger . info ( f \"VALUE OF duplicate { duplicate } \" ) if duplicate is True : return drs_objects # Testing File filtering by size also \"\"\" for drs in drs_objects: logger.info(f\"drs.size: {drs.size} != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\") if(drs.size != os.path.getsize(drs.name)): logger.warning(f\"{drs.name} is the wrong size, consider running this command again with the --duplicate flag so that your current file with the same name is not overwritten by this one that is on the path to downloading\") \"\"\" filtered_objects = [ drs for drs in drs_objects if ( drs . name not in os . listdir ( destination_path )) # or drs.size != os.path.getsize(drs.name) <-- this is used for filtering out wrong sized stuff ] if verbose : logger . info ( f \"VALUE OF FILTERED OBJECTS { filtered_objects } \" ) return filtered_objects","title":"filter_existing_files()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.get_objects","text":"Create tasks for all object_ids, run them in batches, get information about the object. Parameters: Name Type Description Default object_ids List [ str ] list of objects to fetch required Source code in drs_downloader/manager.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def get_objects ( self , object_ids : List [ str ], verbose : bool ) -> List [ DrsObject ]: \"\"\"Create tasks for all object_ids, run them in batches, get information about the object. Args: object_ids: list of objects to fetch \"\"\" drs_objects = [] total_batches = math . ceil ( len ( object_ids ) / self . max_simultaneous_object_retrievers ) # rounding # this would imply that if batch count is 9.3, and you round down the last .3 is never # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all current = 0 for chunk_of_object_ids in DrsAsyncManager . chunker ( object_ids , self . max_simultaneous_object_retrievers ): drs_objects . extend ( asyncio . run ( self . _run_get_objects ( object_ids = chunk_of_object_ids , leave = ( current == total_batches ), verbose = verbose ) ) ) current += 1 return drs_objects","title":"get_objects()"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.optimize_workload","text":"Optimize the workload, sort prioritize and set thread management parameters. Parameters: Name Type Description Default drs_objects List [ DrsObject ] required Returns: Type Description List [ DrsObject ] same list that was passed Source code in drs_downloader/manager.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 def optimize_workload ( self , verbose , drs_objects : List [ DrsObject ] ) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: same list that was passed \"\"\" # Now that we have the objects to download, we have an opportunity to shape the downloads # e.g. are the smallest files first? tweak MAX_* to optimize per workload # TODO: If part sizes changed here, would this result in an error in test recovery? # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case # there is a pytest written for them that will fail otherwise if len ( drs_objects ) == 1 : self . max_simultaneous_part_handlers = 50 self . part_size = 64 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif any ( True for drs_object in drs_objects if ( int ( drs_object . size ) > GB )): self . max_simultaneous_part_handlers = 3 self . part_size = 128 * MB self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) elif all (( drs_object . size < ( 5 * MB )) for drs_object in drs_objects ): self . part_size = 1 * MB self . max_simultaneous_part_handlers = 2 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) else : self . part_size = 128 * MB self . max_simultaneous_part_handlers = 10 self . max_simultaneous_downloaders = 10 if verbose : logger . info ( \"part_size= %s \" , self . part_size ) logger . info ( \"part_handlers= %s \" , self . max_simultaneous_part_handlers ) return drs_objects","title":"optimize_workload()"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager","text":"Bases: ABC Manage DRSClient workload. Source code in drs_downloader/manager.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class DrsManager ( ABC ): \"\"\"Manage DRSClient workload.\"\"\" @abstractmethod def __init__ ( self , drs_client : DrsClient ): self . _drs_client = drs_client @abstractmethod def get_objects ( self , object_ids : List [ str ]) -> List [ DrsObject ]: \"\"\"Fetch list of DRSObject from passed ids. Args: object_ids: list of objects to fetch \"\"\" pass @abstractmethod def download ( self , drs_objects : List [ DrsObject ], destination_path : Path ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable parts, download the files. Args: drs_objects: objects to download destination_path: directory where to write files when complete Returns: list of updated DrsObjects \"\"\" @abstractmethod async def optimize_workload ( self , drs_objects : List [ DrsObject ]) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: \"\"\" # TODO - now that we have the objects to download, we have an opportunity to shape the downloads # TODO - e.g. smallest files first? tweak MAX_* to optimize per workload return drs_objects","title":"DrsManager"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.download","text":"Split the drs_objects into manageable parts, download the files. Parameters: Name Type Description Default drs_objects List [ DrsObject ] objects to download required destination_path Path directory where to write files when complete required Returns: Type Description List [ DrsObject ] list of updated DrsObjects Source code in drs_downloader/manager.py 62 63 64 65 66 67 68 69 70 71 72 73 74 @abstractmethod def download ( self , drs_objects : List [ DrsObject ], destination_path : Path ) -> List [ DrsObject ]: \"\"\"Split the drs_objects into manageable parts, download the files. Args: drs_objects: objects to download destination_path: directory where to write files when complete Returns: list of updated DrsObjects \"\"\"","title":"download()"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.get_objects","text":"Fetch list of DRSObject from passed ids. Parameters: Name Type Description Default object_ids List [ str ] list of objects to fetch required Source code in drs_downloader/manager.py 53 54 55 56 57 58 59 60 @abstractmethod def get_objects ( self , object_ids : List [ str ]) -> List [ DrsObject ]: \"\"\"Fetch list of DRSObject from passed ids. Args: object_ids: list of objects to fetch \"\"\" pass","title":"get_objects()"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.optimize_workload","text":"Optimize the workload, sort prioritize and set thread management parameters. Parameters: Name Type Description Default drs_objects List [ DrsObject ] required Source code in drs_downloader/manager.py 76 77 78 79 80 81 82 83 84 85 86 87 88 @abstractmethod async def optimize_workload ( self , drs_objects : List [ DrsObject ]) -> List [ DrsObject ]: \"\"\" Optimize the workload, sort prioritize and set thread management parameters. Args: drs_objects: Returns: \"\"\" # TODO - now that we have the objects to download, we have an opportunity to shape the downloads # TODO - e.g. smallest files first? tweak MAX_* to optimize per workload return drs_objects","title":"optimize_workload()"},{"location":"reference/manager.html#drs_downloader.manager.Wrapped","text":"Bases: object Source code in drs_downloader/manager.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class Wrapped ( object ): def __init__ ( self , file , hash_method ): \"\"\" Wrap the read() method and calculate hash Args: file: destination file hash_method: instantiated hash_method \"\"\" self . _file = file self . _hash_method = hash_method def read ( self , size ): buffer = self . _file . read ( size ) self . _hash_method . update ( buffer ) return buffer def __getattr__ ( self , attr ): return getattr ( self . _file , attr )","title":"Wrapped"},{"location":"reference/manager.html#drs_downloader.manager.Wrapped.__init__","text":"Wrap the read() method and calculate hash Parameters: Name Type Description Default file destination file required hash_method instantiated hash_method required Source code in drs_downloader/manager.py 92 93 94 95 96 97 98 99 100 def __init__ ( self , file , hash_method ): \"\"\" Wrap the read() method and calculate hash Args: file: destination file hash_method: instantiated hash_method \"\"\" self . _file = file self . _hash_method = hash_method","title":"__init__()"},{"location":"reference/models.html","text":"AccessMethod dataclass Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod Source code in drs_downloader/models.py 10 11 12 13 14 15 16 17 @dataclass class AccessMethod ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod\"\"\" access_url : str \"\"\"An AccessURL that can be used to fetch the actual object bytes.\"\"\" type : str \"\"\"Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file)\"\"\" access_url : str class-attribute An AccessURL that can be used to fetch the actual object bytes. type : str class-attribute Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file) AccessURL dataclass Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl Source code in drs_downloader/models.py 20 21 22 23 24 25 26 27 @dataclass class AccessURL ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl\"\"\" headers : Dict [ str , str ] \"\"\"An optional list of headers to include in the HTTP request to url.\"\"\" url : str \"\"\"A fully resolvable URL that can be used to fetch the actual object bytes.\"\"\" headers : Dict [ str , str ] class-attribute An optional list of headers to include in the HTTP request to url. url : str class-attribute A fully resolvable URL that can be used to fetch the actual object bytes. Checksum dataclass Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum Source code in drs_downloader/models.py 30 31 32 33 34 35 36 37 @dataclass class Checksum ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum\"\"\" checksum : str \"\"\"The hex-string encoded checksum for the data.\"\"\" type : str \"\"\"The digest method used to create the checksum.\"\"\" checksum : str class-attribute The hex-string encoded checksum for the data. type : str class-attribute The digest method used to create the checksum. DrsClient Bases: ABC Interact with DRS service. Source code in drs_downloader/models.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class DrsClient ( ABC ): \"\"\"Interact with DRS service.\"\"\" def __init__ ( self , statistics : Statistics = Statistics ()): self . statistics = statistics @abstractmethod async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: \"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None Args: destination_path: where to save the part drs_object: state of download start: segment start size: segment end \"\"\" pass @abstractmethod async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Retrieve signed url from service return populated DrsObject AccessMethod Args: drs_object: Returns: populated DrsObject \"\"\" pass @abstractmethod async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\" pass download_part ( drs_object , start , size , destination_path , verbose = False ) async abstractmethod Download and save part of a file to disk; on error, update drs_object.errors return None Parameters: Name Type Description Default destination_path Path where to save the part required drs_object DrsObject state of download required start int segment start required size int segment end required Source code in drs_downloader/models.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abstractmethod async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: \"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None Args: destination_path: where to save the part drs_object: state of download start: segment start size: segment end \"\"\" pass get_object ( object_id ) async abstractmethod Retrieve size, checksums, etc. populate DrsObject. Source code in drs_downloader/models.py 122 123 124 125 @abstractmethod async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\" pass sign_url ( drs_object ) async abstractmethod Retrieve signed url from service return populated DrsObject AccessMethod Parameters: Name Type Description Default drs_object DrsObject required Returns: Type Description DrsObject populated DrsObject Source code in drs_downloader/models.py 110 111 112 113 114 115 116 117 118 119 120 @abstractmethod async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Retrieve signed url from service return populated DrsObject AccessMethod Args: drs_object: Returns: populated DrsObject \"\"\" pass DrsObject dataclass Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject Source code in drs_downloader/models.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass class DrsObject ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject\"\"\" id : str \"\"\"An identifier unique to this DrsObject.\"\"\" self_uri : str \"\"\"A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object.\"\"\" checksums : List [ Checksum ] \"\"\"Needed for integrity check.\"\"\" size : int \"\"\"Needed for multi part download.\"\"\" name : str \"\"\"A string that can be used to name a DrsObject.\"\"\" file_parts : List [ Path ] = field ( default_factory = list ) \"\"\"List of file parts in order of assembly.\"\"\" errors : List [ str ] = field ( default_factory = list ) \"\"\"List of errors.\"\"\" access_methods : List [ AccessMethod ] = field ( default_factory = list ) \"\"\"Signed url.\"\"\" access_methods : List [ AccessMethod ] = field ( default_factory = list ) class-attribute Signed url. checksums : List [ Checksum ] class-attribute Needed for integrity check. errors : List [ str ] = field ( default_factory = list ) class-attribute List of errors. file_parts : List [ Path ] = field ( default_factory = list ) class-attribute List of file parts in order of assembly. id : str class-attribute An identifier unique to this DrsObject. name : str class-attribute A string that can be used to name a DrsObject. self_uri : str class-attribute A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object. size : int class-attribute Needed for multi part download. Statistics dataclass This is where we can share data between threads Source code in drs_downloader/models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class Statistics : \"\"\"This is where we can share data between threads\"\"\" lock : threading . Lock = threading . Lock () max_files_open : int = 0 pid : object = os . getpid () def set_max_files_open ( self ): \"\"\"Threadsafe way to determine current number of open files. Note: only tested on Mac \"\"\" self . lock . acquire () system = platform . system () if system == \"Darwin\" : open_fd = len ( set ( os . listdir ( \"/dev/fd/\" ))) elif system == \"Windows\" : # TODO install psutils - len(Process.open_files()) open_fd = 0 else : open_fd = len ( set ( os . listdir ( f \"/proc/ { self . pid } /fd/\" ))) if open_fd > self . max_files_open : self . max_files_open = open_fd self . lock . release () set_max_files_open () Threadsafe way to determine current number of open files. Note: only tested on Mac Source code in drs_downloader/models.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def set_max_files_open ( self ): \"\"\"Threadsafe way to determine current number of open files. Note: only tested on Mac \"\"\" self . lock . acquire () system = platform . system () if system == \"Darwin\" : open_fd = len ( set ( os . listdir ( \"/dev/fd/\" ))) elif system == \"Windows\" : # TODO install psutils - len(Process.open_files()) open_fd = 0 else : open_fd = len ( set ( os . listdir ( f \"/proc/ { self . pid } /fd/\" ))) if open_fd > self . max_files_open : self . max_files_open = open_fd self . lock . release ()","title":"models"},{"location":"reference/models.html#drs_downloader.models.AccessMethod","text":"Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod Source code in drs_downloader/models.py 10 11 12 13 14 15 16 17 @dataclass class AccessMethod ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod\"\"\" access_url : str \"\"\"An AccessURL that can be used to fetch the actual object bytes.\"\"\" type : str \"\"\"Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file)\"\"\"","title":"AccessMethod"},{"location":"reference/models.html#drs_downloader.models.AccessMethod.access_url","text":"An AccessURL that can be used to fetch the actual object bytes.","title":"access_url"},{"location":"reference/models.html#drs_downloader.models.AccessMethod.type","text":"Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file)","title":"type"},{"location":"reference/models.html#drs_downloader.models.AccessURL","text":"Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl Source code in drs_downloader/models.py 20 21 22 23 24 25 26 27 @dataclass class AccessURL ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl\"\"\" headers : Dict [ str , str ] \"\"\"An optional list of headers to include in the HTTP request to url.\"\"\" url : str \"\"\"A fully resolvable URL that can be used to fetch the actual object bytes.\"\"\"","title":"AccessURL"},{"location":"reference/models.html#drs_downloader.models.AccessURL.headers","text":"An optional list of headers to include in the HTTP request to url.","title":"headers"},{"location":"reference/models.html#drs_downloader.models.AccessURL.url","text":"A fully resolvable URL that can be used to fetch the actual object bytes.","title":"url"},{"location":"reference/models.html#drs_downloader.models.Checksum","text":"Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum Source code in drs_downloader/models.py 30 31 32 33 34 35 36 37 @dataclass class Checksum ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum\"\"\" checksum : str \"\"\"The hex-string encoded checksum for the data.\"\"\" type : str \"\"\"The digest method used to create the checksum.\"\"\"","title":"Checksum"},{"location":"reference/models.html#drs_downloader.models.Checksum.checksum","text":"The hex-string encoded checksum for the data.","title":"checksum"},{"location":"reference/models.html#drs_downloader.models.Checksum.type","text":"The digest method used to create the checksum.","title":"type"},{"location":"reference/models.html#drs_downloader.models.DrsClient","text":"Bases: ABC Interact with DRS service. Source code in drs_downloader/models.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class DrsClient ( ABC ): \"\"\"Interact with DRS service.\"\"\" def __init__ ( self , statistics : Statistics = Statistics ()): self . statistics = statistics @abstractmethod async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: \"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None Args: destination_path: where to save the part drs_object: state of download start: segment start size: segment end \"\"\" pass @abstractmethod async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Retrieve signed url from service return populated DrsObject AccessMethod Args: drs_object: Returns: populated DrsObject \"\"\" pass @abstractmethod async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\" pass","title":"DrsClient"},{"location":"reference/models.html#drs_downloader.models.DrsClient.download_part","text":"Download and save part of a file to disk; on error, update drs_object.errors return None Parameters: Name Type Description Default destination_path Path where to save the part required drs_object DrsObject state of download required start int segment start required size int segment end required Source code in drs_downloader/models.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abstractmethod async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: \"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None Args: destination_path: where to save the part drs_object: state of download start: segment start size: segment end \"\"\" pass","title":"download_part()"},{"location":"reference/models.html#drs_downloader.models.DrsClient.get_object","text":"Retrieve size, checksums, etc. populate DrsObject. Source code in drs_downloader/models.py 122 123 124 125 @abstractmethod async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\" pass","title":"get_object()"},{"location":"reference/models.html#drs_downloader.models.DrsClient.sign_url","text":"Retrieve signed url from service return populated DrsObject AccessMethod Parameters: Name Type Description Default drs_object DrsObject required Returns: Type Description DrsObject populated DrsObject Source code in drs_downloader/models.py 110 111 112 113 114 115 116 117 118 119 120 @abstractmethod async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Retrieve signed url from service return populated DrsObject AccessMethod Args: drs_object: Returns: populated DrsObject \"\"\" pass","title":"sign_url()"},{"location":"reference/models.html#drs_downloader.models.DrsObject","text":"Bases: object See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject Source code in drs_downloader/models.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass class DrsObject ( object ): \"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject\"\"\" id : str \"\"\"An identifier unique to this DrsObject.\"\"\" self_uri : str \"\"\"A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object.\"\"\" checksums : List [ Checksum ] \"\"\"Needed for integrity check.\"\"\" size : int \"\"\"Needed for multi part download.\"\"\" name : str \"\"\"A string that can be used to name a DrsObject.\"\"\" file_parts : List [ Path ] = field ( default_factory = list ) \"\"\"List of file parts in order of assembly.\"\"\" errors : List [ str ] = field ( default_factory = list ) \"\"\"List of errors.\"\"\" access_methods : List [ AccessMethod ] = field ( default_factory = list ) \"\"\"Signed url.\"\"\"","title":"DrsObject"},{"location":"reference/models.html#drs_downloader.models.DrsObject.access_methods","text":"Signed url.","title":"access_methods"},{"location":"reference/models.html#drs_downloader.models.DrsObject.checksums","text":"Needed for integrity check.","title":"checksums"},{"location":"reference/models.html#drs_downloader.models.DrsObject.errors","text":"List of errors.","title":"errors"},{"location":"reference/models.html#drs_downloader.models.DrsObject.file_parts","text":"List of file parts in order of assembly.","title":"file_parts"},{"location":"reference/models.html#drs_downloader.models.DrsObject.id","text":"An identifier unique to this DrsObject.","title":"id"},{"location":"reference/models.html#drs_downloader.models.DrsObject.name","text":"A string that can be used to name a DrsObject.","title":"name"},{"location":"reference/models.html#drs_downloader.models.DrsObject.self_uri","text":"A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object.","title":"self_uri"},{"location":"reference/models.html#drs_downloader.models.DrsObject.size","text":"Needed for multi part download.","title":"size"},{"location":"reference/models.html#drs_downloader.models.Statistics","text":"This is where we can share data between threads Source code in drs_downloader/models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class Statistics : \"\"\"This is where we can share data between threads\"\"\" lock : threading . Lock = threading . Lock () max_files_open : int = 0 pid : object = os . getpid () def set_max_files_open ( self ): \"\"\"Threadsafe way to determine current number of open files. Note: only tested on Mac \"\"\" self . lock . acquire () system = platform . system () if system == \"Darwin\" : open_fd = len ( set ( os . listdir ( \"/dev/fd/\" ))) elif system == \"Windows\" : # TODO install psutils - len(Process.open_files()) open_fd = 0 else : open_fd = len ( set ( os . listdir ( f \"/proc/ { self . pid } /fd/\" ))) if open_fd > self . max_files_open : self . max_files_open = open_fd self . lock . release ()","title":"Statistics"},{"location":"reference/models.html#drs_downloader.models.Statistics.set_max_files_open","text":"Threadsafe way to determine current number of open files. Note: only tested on Mac Source code in drs_downloader/models.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def set_max_files_open ( self ): \"\"\"Threadsafe way to determine current number of open files. Note: only tested on Mac \"\"\" self . lock . acquire () system = platform . system () if system == \"Darwin\" : open_fd = len ( set ( os . listdir ( \"/dev/fd/\" ))) elif system == \"Windows\" : # TODO install psutils - len(Process.open_files()) open_fd = 0 else : open_fd = len ( set ( os . listdir ( f \"/proc/ { self . pid } /fd/\" ))) if open_fd > self . max_files_open : self . max_files_open = open_fd self . lock . release ()","title":"set_max_files_open()"},{"location":"reference/upgrader.html","text":"Upgrader Bases: ABC Source code in drs_downloader/upgrader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class Upgrader ( ABC ): def __init__ ( self ): release_path = \"anvilproject/drs_downloader/releases/latest\" self . release_url = f \"https://github.com/ { release_path } \" self . api_url = f \"https://api.github.com/repos/ { release_path } \" def upgrade ( self , dest : str = os . getcwd (), force = False ) -> Path : \"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Args: dest (str, optional): download destination. Defaults to os.getcwd(). force (bool, optional): forces upgrade even if version is up to date. Defaults to False. Raises: Exception: If the operating system can not be reliably determined Exception: If the checksum for the new executable does not match the expected value Returns: Path: The downloaded executable. \"\"\" # Perform upgrade only if the program is being run as an executable and not as a script if getattr ( sys , \"frozen\" , False ) and hasattr ( sys , \"_MEIPASS\" ): logger . info ( \"running in a PyInstaller bundle\" ) else : logger . info ( \"Running from a script\" ) # Upgrade if newer version is available json = requests . get ( self . api_url ) . json () new_version = version . parse ( json [ \"tag_name\" ]) current_version = version . parse ( __version__ ) if current_version >= new_version : logger . info ( \"Latest version already installed\" ) if force is False : return # Determine download url for operating system system = platform . system () if system == \"Darwin\" : exe = \"drs-downloader-macOS\" elif system == \"Linux\" : exe = \"drs-downloader-Linux\" elif system == \"Windows\" : exe = \"drs-downloader-Windows.exe\" else : raise Exception ( f \"Unknown operating system detected. See the release page for manual upgrade: { self . release_url } \" ) download_url = f \" { self . release_url } /download/ { exe } \" checksum_url = f \" { self . release_url } /download/checksums.txt\" # Download executable and checksum files to temporary directory for checksum verification verified_exe = None # We use a temporary directory here to prevent files that might not pass the # checksum step from remaining in the user's filesystem. with tempfile . TemporaryDirectory () as tmp_dir : unverified_exe = self . _download_file ( download_url , tmp_dir ) checksum_path = self . _download_file ( checksum_url , tmp_dir ) checksums_match = self . _verify_checksums ( unverified_exe , checksum_path ) if checksums_match is False : raise Exception ( \"Actual hash does not match expected hash\" ) # Backup old executable self . _backup ( Path ( dest , exe )) # If checksum is verified move new executable to current directory verified_exe = shutil . move ( unverified_exe , dest ) return Path ( verified_exe ) def _backup ( self , old_exe : Path ): \"\"\"Backups the executable if it is already present in the destination directory. Example: Download destination is /Users/liam and /Users/liam/drs_downloader-macOS already exists so it will be moved to /Users/liam/drs-downloader-macOS.bak/drs-downloader-macOS. Args: dest (str): download destination \"\"\" if old_exe . is_file () is False : return backup_dir = Path ( old_exe . parent , f \" { old_exe . name } .bak\" ) backup_dir . mkdir ( parents = True , exist_ok = True ) shutil . move ( old_exe , backup_dir ) def _download_file ( self , url : str , dest : str ) -> Path : \"\"\"Downloads a file given an URL. Example: url is https://example.com/foo.zip and dest is /Users/liam so foo will be downloaded to /Users/liam/foo.zip Args: url (str): URL to request the file from dest (str): download destination Returns: Path: path of the downloaded file \"\"\" response = requests . get ( url ) file_name = url . split ( \"/\" )[ - 1 ] path = Path ( dest , file_name ) with open ( path , \"wb\" ) as f : f . write ( response . content ) return path def _verify_checksums ( self , file : str , checksums : str ) -> bool : \"\"\"Compares checksums for a given file against those in a given list (typically checksums.txt) Args: file (str): File to verify checksums for checksums (str): File containing checksums Returns: bool: True if the expected and actual checksums match, False otherwise \"\"\" expected_sha = \"\" with open ( checksums , \"r\" ) as checksum_file : lines = checksum_file . readlines () for line in lines : # If filename is found then use that checksum as the expected value if file . stem in line : expected_sha = line . split ()[ 0 ] # Verify checksums sha_hash = hashlib . sha256 () sha_hash . update ( open ( file , \"rb\" ) . read ()) actual_sha = sha_hash . hexdigest () return expected_sha == actual_sha upgrade ( dest = os . getcwd (), force = False ) Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Parameters: Name Type Description Default dest str download destination. Defaults to os.getcwd(). os.getcwd() force bool forces upgrade even if version is up to date. Defaults to False. False Raises: Type Description Exception If the operating system can not be reliably determined Exception If the checksum for the new executable does not match the expected value Returns: Name Type Description Path Path The downloaded executable. Source code in drs_downloader/upgrader.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def upgrade ( self , dest : str = os . getcwd (), force = False ) -> Path : \"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Args: dest (str, optional): download destination. Defaults to os.getcwd(). force (bool, optional): forces upgrade even if version is up to date. Defaults to False. Raises: Exception: If the operating system can not be reliably determined Exception: If the checksum for the new executable does not match the expected value Returns: Path: The downloaded executable. \"\"\" # Perform upgrade only if the program is being run as an executable and not as a script if getattr ( sys , \"frozen\" , False ) and hasattr ( sys , \"_MEIPASS\" ): logger . info ( \"running in a PyInstaller bundle\" ) else : logger . info ( \"Running from a script\" ) # Upgrade if newer version is available json = requests . get ( self . api_url ) . json () new_version = version . parse ( json [ \"tag_name\" ]) current_version = version . parse ( __version__ ) if current_version >= new_version : logger . info ( \"Latest version already installed\" ) if force is False : return # Determine download url for operating system system = platform . system () if system == \"Darwin\" : exe = \"drs-downloader-macOS\" elif system == \"Linux\" : exe = \"drs-downloader-Linux\" elif system == \"Windows\" : exe = \"drs-downloader-Windows.exe\" else : raise Exception ( f \"Unknown operating system detected. See the release page for manual upgrade: { self . release_url } \" ) download_url = f \" { self . release_url } /download/ { exe } \" checksum_url = f \" { self . release_url } /download/checksums.txt\" # Download executable and checksum files to temporary directory for checksum verification verified_exe = None # We use a temporary directory here to prevent files that might not pass the # checksum step from remaining in the user's filesystem. with tempfile . TemporaryDirectory () as tmp_dir : unverified_exe = self . _download_file ( download_url , tmp_dir ) checksum_path = self . _download_file ( checksum_url , tmp_dir ) checksums_match = self . _verify_checksums ( unverified_exe , checksum_path ) if checksums_match is False : raise Exception ( \"Actual hash does not match expected hash\" ) # Backup old executable self . _backup ( Path ( dest , exe )) # If checksum is verified move new executable to current directory verified_exe = shutil . move ( unverified_exe , dest ) return Path ( verified_exe )","title":"upgrader"},{"location":"reference/upgrader.html#drs_downloader.upgrader.Upgrader","text":"Bases: ABC Source code in drs_downloader/upgrader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class Upgrader ( ABC ): def __init__ ( self ): release_path = \"anvilproject/drs_downloader/releases/latest\" self . release_url = f \"https://github.com/ { release_path } \" self . api_url = f \"https://api.github.com/repos/ { release_path } \" def upgrade ( self , dest : str = os . getcwd (), force = False ) -> Path : \"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Args: dest (str, optional): download destination. Defaults to os.getcwd(). force (bool, optional): forces upgrade even if version is up to date. Defaults to False. Raises: Exception: If the operating system can not be reliably determined Exception: If the checksum for the new executable does not match the expected value Returns: Path: The downloaded executable. \"\"\" # Perform upgrade only if the program is being run as an executable and not as a script if getattr ( sys , \"frozen\" , False ) and hasattr ( sys , \"_MEIPASS\" ): logger . info ( \"running in a PyInstaller bundle\" ) else : logger . info ( \"Running from a script\" ) # Upgrade if newer version is available json = requests . get ( self . api_url ) . json () new_version = version . parse ( json [ \"tag_name\" ]) current_version = version . parse ( __version__ ) if current_version >= new_version : logger . info ( \"Latest version already installed\" ) if force is False : return # Determine download url for operating system system = platform . system () if system == \"Darwin\" : exe = \"drs-downloader-macOS\" elif system == \"Linux\" : exe = \"drs-downloader-Linux\" elif system == \"Windows\" : exe = \"drs-downloader-Windows.exe\" else : raise Exception ( f \"Unknown operating system detected. See the release page for manual upgrade: { self . release_url } \" ) download_url = f \" { self . release_url } /download/ { exe } \" checksum_url = f \" { self . release_url } /download/checksums.txt\" # Download executable and checksum files to temporary directory for checksum verification verified_exe = None # We use a temporary directory here to prevent files that might not pass the # checksum step from remaining in the user's filesystem. with tempfile . TemporaryDirectory () as tmp_dir : unverified_exe = self . _download_file ( download_url , tmp_dir ) checksum_path = self . _download_file ( checksum_url , tmp_dir ) checksums_match = self . _verify_checksums ( unverified_exe , checksum_path ) if checksums_match is False : raise Exception ( \"Actual hash does not match expected hash\" ) # Backup old executable self . _backup ( Path ( dest , exe )) # If checksum is verified move new executable to current directory verified_exe = shutil . move ( unverified_exe , dest ) return Path ( verified_exe ) def _backup ( self , old_exe : Path ): \"\"\"Backups the executable if it is already present in the destination directory. Example: Download destination is /Users/liam and /Users/liam/drs_downloader-macOS already exists so it will be moved to /Users/liam/drs-downloader-macOS.bak/drs-downloader-macOS. Args: dest (str): download destination \"\"\" if old_exe . is_file () is False : return backup_dir = Path ( old_exe . parent , f \" { old_exe . name } .bak\" ) backup_dir . mkdir ( parents = True , exist_ok = True ) shutil . move ( old_exe , backup_dir ) def _download_file ( self , url : str , dest : str ) -> Path : \"\"\"Downloads a file given an URL. Example: url is https://example.com/foo.zip and dest is /Users/liam so foo will be downloaded to /Users/liam/foo.zip Args: url (str): URL to request the file from dest (str): download destination Returns: Path: path of the downloaded file \"\"\" response = requests . get ( url ) file_name = url . split ( \"/\" )[ - 1 ] path = Path ( dest , file_name ) with open ( path , \"wb\" ) as f : f . write ( response . content ) return path def _verify_checksums ( self , file : str , checksums : str ) -> bool : \"\"\"Compares checksums for a given file against those in a given list (typically checksums.txt) Args: file (str): File to verify checksums for checksums (str): File containing checksums Returns: bool: True if the expected and actual checksums match, False otherwise \"\"\" expected_sha = \"\" with open ( checksums , \"r\" ) as checksum_file : lines = checksum_file . readlines () for line in lines : # If filename is found then use that checksum as the expected value if file . stem in line : expected_sha = line . split ()[ 0 ] # Verify checksums sha_hash = hashlib . sha256 () sha_hash . update ( open ( file , \"rb\" ) . read ()) actual_sha = sha_hash . hexdigest () return expected_sha == actual_sha","title":"Upgrader"},{"location":"reference/upgrader.html#drs_downloader.upgrader.Upgrader.upgrade","text":"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Parameters: Name Type Description Default dest str download destination. Defaults to os.getcwd(). os.getcwd() force bool forces upgrade even if version is up to date. Defaults to False. False Raises: Type Description Exception If the operating system can not be reliably determined Exception If the checksum for the new executable does not match the expected value Returns: Name Type Description Path Path The downloaded executable. Source code in drs_downloader/upgrader.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def upgrade ( self , dest : str = os . getcwd (), force = False ) -> Path : \"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/ Args: dest (str, optional): download destination. Defaults to os.getcwd(). force (bool, optional): forces upgrade even if version is up to date. Defaults to False. Raises: Exception: If the operating system can not be reliably determined Exception: If the checksum for the new executable does not match the expected value Returns: Path: The downloaded executable. \"\"\" # Perform upgrade only if the program is being run as an executable and not as a script if getattr ( sys , \"frozen\" , False ) and hasattr ( sys , \"_MEIPASS\" ): logger . info ( \"running in a PyInstaller bundle\" ) else : logger . info ( \"Running from a script\" ) # Upgrade if newer version is available json = requests . get ( self . api_url ) . json () new_version = version . parse ( json [ \"tag_name\" ]) current_version = version . parse ( __version__ ) if current_version >= new_version : logger . info ( \"Latest version already installed\" ) if force is False : return # Determine download url for operating system system = platform . system () if system == \"Darwin\" : exe = \"drs-downloader-macOS\" elif system == \"Linux\" : exe = \"drs-downloader-Linux\" elif system == \"Windows\" : exe = \"drs-downloader-Windows.exe\" else : raise Exception ( f \"Unknown operating system detected. See the release page for manual upgrade: { self . release_url } \" ) download_url = f \" { self . release_url } /download/ { exe } \" checksum_url = f \" { self . release_url } /download/checksums.txt\" # Download executable and checksum files to temporary directory for checksum verification verified_exe = None # We use a temporary directory here to prevent files that might not pass the # checksum step from remaining in the user's filesystem. with tempfile . TemporaryDirectory () as tmp_dir : unverified_exe = self . _download_file ( download_url , tmp_dir ) checksum_path = self . _download_file ( checksum_url , tmp_dir ) checksums_match = self . _verify_checksums ( unverified_exe , checksum_path ) if checksums_match is False : raise Exception ( \"Actual hash does not match expected hash\" ) # Backup old executable self . _backup ( Path ( dest , exe )) # If checksum is verified move new executable to current directory verified_exe = shutil . move ( unverified_exe , dest ) return Path ( verified_exe )","title":"upgrade()"},{"location":"reference/clients/index.html","text":"Download clients that will be used by the manager module to perform the following: authentication requests URL signing part download and reassembly","title":"clients"},{"location":"reference/clients/gen3.html","text":"Gen3DrsClient Bases: DrsClient Calls the Gen3 DRS server indexd Source code in drs_downloader/clients/gen3.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class Gen3DrsClient ( DrsClient ): \"\"\" Calls the Gen3 DRS server indexd \"\"\" def __init__ ( self , api_key_path , endpoint , access_token_resource_path = \"/user/credentials/cdis/access_token\" , drs_api = \"/ga4gh/drs/v1/objects/\" , * args , ** kwargs , ): super () . __init__ ( * args , ** kwargs ) self . authorized = None self . api_key = None self . endpoint = endpoint self . token = None self . access_token_resource_path = access_token_resource_path self . api_key_path = api_key_path self . drs_api = drs_api async def authorize ( self ): full_key_path = os . path . expanduser ( self . api_key_path ) try : with open ( full_key_path ) as f : self . api_key = json . load ( f ) code = await self . update_access_token () if code == 401 : logger . error ( \"Invalid access token in {} \" . format ( full_key_path )) self . api_key = None elif code != 200 : logger . error ( \"Error {} getting Access token for {} \" . format ( code , self . endpoint ) ) logger . error ( \"Using {} \" . format ( full_key_path )) self . api_key = None except Exception as e : self . api_key = None raise e # Obtain an access_token using the provided Fence API key. # The client object will retain the access key for subsequent calls async def update_access_token ( self ): headers = { \"Content-Type\" : \"application/json\" } api_url = \" {0}{1} \" . format ( self . endpoint , self . access_token_resource_path ) async with aiohttp . ClientSession ( headers = headers ) as session : response = await session . post ( api_url , headers = headers , json = self . api_key ) if response . status == 200 : resp = await response . json () self . token = resp [ \"access_token\" ] self . authorized = True else : self . authorized = False return response . status async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path ) -> Optional [ Path ]: try : if not self . authorized : await self . authorize () headers = { \"Range\" : f \"bytes= { start } - { size } \" } file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" Path ( file_name ) . parent . mkdir ( parents = True , exist_ok = True ) async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( drs_object . access_methods [ 0 ] . access_url ) as request : file = await aiofiles . open ( file_name , \"wb\" ) self . statistics . set_max_files_open () async for data in request . content . iter_any (): # uses less memory await file . write ( data ) await file . close () return Path ( file_name ) except Exception as e : logger . error ( f \"gen3.download_part { str ( e ) } \" ) drs_object . errors . append ( str ( e )) return None async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Call fence's /user/data/download/ endpoint.\"\"\" headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint } /user/data/download/ { drs_object . id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"url\" in resp , resp url_ = resp [ \"url\" ] drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = \"s3\" ) ] return drs_object except ClientResponseError as e : drs_object . errors . append ( str ( e )) return drs_object async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if not self . authorized : await self . authorize () headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint }{ self . drs_api } / { object_id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert resp [ \"checksums\" ][ 0 ][ \"type\" ] == \"md5\" , resp md5_ = resp [ \"checksums\" ][ 0 ][ \"checksum\" ] size_ = resp [ \"size\" ] name_ = resp [ \"name\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , access_methods = [ AccessMethod ( access_url = \"\" , type = \"gs\" )], ) except ClientResponseError as e : return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) get_object ( object_id ) async Sends a POST request for the signed URL, hash, and file size of a given DRS object. Parameters: Name Type Description Default object_id str DRS URI required Raises: Type Description Exception The request was rejected by the server Returns: Name Type Description DownloadURL DrsObject The downloadable bundle ready for async download Source code in drs_downloader/clients/gen3.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if not self . authorized : await self . authorize () headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint }{ self . drs_api } / { object_id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert resp [ \"checksums\" ][ 0 ][ \"type\" ] == \"md5\" , resp md5_ = resp [ \"checksums\" ][ 0 ][ \"checksum\" ] size_ = resp [ \"size\" ] name_ = resp [ \"name\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , access_methods = [ AccessMethod ( access_url = \"\" , type = \"gs\" )], ) except ClientResponseError as e : return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) sign_url ( drs_object ) async Call fence's /user/data/download/ endpoint. Source code in drs_downloader/clients/gen3.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Call fence's /user/data/download/ endpoint.\"\"\" headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint } /user/data/download/ { drs_object . id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"url\" in resp , resp url_ = resp [ \"url\" ] drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = \"s3\" ) ] return drs_object except ClientResponseError as e : drs_object . errors . append ( str ( e )) return drs_object","title":"gen3"},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient","text":"Bases: DrsClient Calls the Gen3 DRS server indexd Source code in drs_downloader/clients/gen3.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class Gen3DrsClient ( DrsClient ): \"\"\" Calls the Gen3 DRS server indexd \"\"\" def __init__ ( self , api_key_path , endpoint , access_token_resource_path = \"/user/credentials/cdis/access_token\" , drs_api = \"/ga4gh/drs/v1/objects/\" , * args , ** kwargs , ): super () . __init__ ( * args , ** kwargs ) self . authorized = None self . api_key = None self . endpoint = endpoint self . token = None self . access_token_resource_path = access_token_resource_path self . api_key_path = api_key_path self . drs_api = drs_api async def authorize ( self ): full_key_path = os . path . expanduser ( self . api_key_path ) try : with open ( full_key_path ) as f : self . api_key = json . load ( f ) code = await self . update_access_token () if code == 401 : logger . error ( \"Invalid access token in {} \" . format ( full_key_path )) self . api_key = None elif code != 200 : logger . error ( \"Error {} getting Access token for {} \" . format ( code , self . endpoint ) ) logger . error ( \"Using {} \" . format ( full_key_path )) self . api_key = None except Exception as e : self . api_key = None raise e # Obtain an access_token using the provided Fence API key. # The client object will retain the access key for subsequent calls async def update_access_token ( self ): headers = { \"Content-Type\" : \"application/json\" } api_url = \" {0}{1} \" . format ( self . endpoint , self . access_token_resource_path ) async with aiohttp . ClientSession ( headers = headers ) as session : response = await session . post ( api_url , headers = headers , json = self . api_key ) if response . status == 200 : resp = await response . json () self . token = resp [ \"access_token\" ] self . authorized = True else : self . authorized = False return response . status async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path ) -> Optional [ Path ]: try : if not self . authorized : await self . authorize () headers = { \"Range\" : f \"bytes= { start } - { size } \" } file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" Path ( file_name ) . parent . mkdir ( parents = True , exist_ok = True ) async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( drs_object . access_methods [ 0 ] . access_url ) as request : file = await aiofiles . open ( file_name , \"wb\" ) self . statistics . set_max_files_open () async for data in request . content . iter_any (): # uses less memory await file . write ( data ) await file . close () return Path ( file_name ) except Exception as e : logger . error ( f \"gen3.download_part { str ( e ) } \" ) drs_object . errors . append ( str ( e )) return None async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Call fence's /user/data/download/ endpoint.\"\"\" headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint } /user/data/download/ { drs_object . id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"url\" in resp , resp url_ = resp [ \"url\" ] drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = \"s3\" ) ] return drs_object except ClientResponseError as e : drs_object . errors . append ( str ( e )) return drs_object async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if not self . authorized : await self . authorize () headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint }{ self . drs_api } / { object_id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert resp [ \"checksums\" ][ 0 ][ \"type\" ] == \"md5\" , resp md5_ = resp [ \"checksums\" ][ 0 ][ \"checksum\" ] size_ = resp [ \"size\" ] name_ = resp [ \"name\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , access_methods = [ AccessMethod ( access_url = \"\" , type = \"gs\" )], ) except ClientResponseError as e : return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], )","title":"Gen3DrsClient"},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient.get_object","text":"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Parameters: Name Type Description Default object_id str DRS URI required Raises: Type Description Exception The request was rejected by the server Returns: Name Type Description DownloadURL DrsObject The downloadable bundle ready for async download Source code in drs_downloader/clients/gen3.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def get_object ( self , object_id : str ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if not self . authorized : await self . authorize () headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint }{ self . drs_api } / { object_id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert resp [ \"checksums\" ][ 0 ][ \"type\" ] == \"md5\" , resp md5_ = resp [ \"checksums\" ][ 0 ][ \"checksum\" ] size_ = resp [ \"size\" ] name_ = resp [ \"name\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , access_methods = [ AccessMethod ( access_url = \"\" , type = \"gs\" )], ) except ClientResponseError as e : return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], )","title":"get_object()"},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient.sign_url","text":"Call fence's /user/data/download/ endpoint. Source code in drs_downloader/clients/gen3.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 async def sign_url ( self , drs_object : DrsObject ) -> DrsObject : \"\"\"Call fence's /user/data/download/ endpoint.\"\"\" headers = { \"authorization\" : \"Bearer \" + self . token , \"content-type\" : \"application/json\" , } async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( url = f \" { self . endpoint } /user/data/download/ { drs_object . id . split ( ':' )[ - 1 ] } \" ) as response : try : self . statistics . set_max_files_open () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"url\" in resp , resp url_ = resp [ \"url\" ] drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = \"s3\" ) ] return drs_object except ClientResponseError as e : drs_object . errors . append ( str ( e )) return drs_object","title":"sign_url()"},{"location":"reference/clients/mock.html","text":"MockDrsClient Bases: DrsClient Simulate responses from server. Source code in drs_downloader/clients/mock.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class MockDrsClient ( DrsClient ): \"\"\"Simulate responses from server.\"\"\" async def sign_url ( self , drs_object : DrsObject , verbose : bool = False ) -> Optional [ DrsObject ]: \"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject Args: drs_object: Returns: populated DrsObject \"\"\" # simulate a failed signature if drs_object . id == BAD_SIGNATURE : return None # here we sleep while the file is open and measure total files open fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"sign url\" ) self . statistics . set_max_files_open () fp . close () # provide expected result, e.g. X-Signature access_url = f \" { drs_object . self_uri } ?X-Signature= { uuid . uuid1 () } \" # place it in the right spot in the drs object drs_object . access_methods . append ( AccessMethod ( access_url = access_url , type = \"gs\" )) return drs_object async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Path : \"\"\"Actually download a part. Args: destination_path: drs_object: start: size: Returns: full path to that part. \"\"\" # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range length_ = size - start + 1 # logger.info((drs_object.name, start, length_)) # logger.error(\"ERROR1 %s\",drs_object) if BAD_ID in drs_object . self_uri : logger . warning ( f \"Mock bad id { drs_object . self_uri } \" ) drs_object . errors = [ \"Mock error BAD_ID\" ] return None with open ( Path ( os . getcwd (), f \" { drs_object . name } .golden\" ), \"rb\" ) as f : f . seek ( start ) data = f . read ( length_ ) ( fd , name ,) = tempfile . mkstemp ( prefix = f \" { drs_object . name } . { start } . { size } .\" , suffix = \".part\" , dir = str ( destination_path ), ) with os . fdopen ( fd , \"wb\" ) as fp : sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( data ) self . statistics . set_max_files_open () fp . close () return Path ( name ) async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Args: object_id: Returns: \"\"\" # \"\"\"Actually fetch the object. # # \"\"\" fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"get object\" ) self . statistics . set_max_files_open () fp . close () id_ = str ( uuid . uuid4 ()) name_ = f \"file- { id_ } .txt\" line = b \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \\n \" # noqa line_len = len ( line ) number_of_lines = int ( random . randint ( line_len , MAX_SIZE_OF_OBJECT ) / line_len ) lines = line * number_of_lines size_ = len ( lines ) # write it for testing destination_dir = Path ( os . getcwd ()) destination_dir . mkdir ( parents = True , exist_ok = True ) with open ( Path ( f \" { destination_dir } / { name_ } .golden\" ), \"wb\" ) as f : f . write ( lines ) checksum = Checksum ( hashlib . new ( \"md5\" , lines ) . hexdigest (), type = \"md5\" ) # simulate an incorrect MD5 if object_id == BAD_MD5 : checksum = Checksum ( hashlib . new ( \"md5\" , line ) . hexdigest (), type = \"md5\" ) # simulate an incorrect size if object_id == INCORRECT_SIZE : size_ += 1000 return DrsObject ( self_uri = object_id , size = size_ , # md5, etag, crc32c, trunc512, or sha1 checksums = [ checksum ], id = id_ , name = name_ , ) download_part ( drs_object , start , size , destination_path , verbose = False ) async Actually download a part. Parameters: Name Type Description Default destination_path Path required drs_object DrsObject required start int required size int required Returns: Type Description Path full path to that part. Source code in drs_downloader/clients/mock.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Path : \"\"\"Actually download a part. Args: destination_path: drs_object: start: size: Returns: full path to that part. \"\"\" # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range length_ = size - start + 1 # logger.info((drs_object.name, start, length_)) # logger.error(\"ERROR1 %s\",drs_object) if BAD_ID in drs_object . self_uri : logger . warning ( f \"Mock bad id { drs_object . self_uri } \" ) drs_object . errors = [ \"Mock error BAD_ID\" ] return None with open ( Path ( os . getcwd (), f \" { drs_object . name } .golden\" ), \"rb\" ) as f : f . seek ( start ) data = f . read ( length_ ) ( fd , name ,) = tempfile . mkstemp ( prefix = f \" { drs_object . name } . { start } . { size } .\" , suffix = \".part\" , dir = str ( destination_path ), ) with os . fdopen ( fd , \"wb\" ) as fp : sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( data ) self . statistics . set_max_files_open () fp . close () return Path ( name ) get_object ( object_id , verbose = False ) async Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Parameters: Name Type Description Default object_id str required Source code in drs_downloader/clients/mock.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Args: object_id: Returns: \"\"\" # \"\"\"Actually fetch the object. # # \"\"\" fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"get object\" ) self . statistics . set_max_files_open () fp . close () id_ = str ( uuid . uuid4 ()) name_ = f \"file- { id_ } .txt\" line = b \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \\n \" # noqa line_len = len ( line ) number_of_lines = int ( random . randint ( line_len , MAX_SIZE_OF_OBJECT ) / line_len ) lines = line * number_of_lines size_ = len ( lines ) # write it for testing destination_dir = Path ( os . getcwd ()) destination_dir . mkdir ( parents = True , exist_ok = True ) with open ( Path ( f \" { destination_dir } / { name_ } .golden\" ), \"wb\" ) as f : f . write ( lines ) checksum = Checksum ( hashlib . new ( \"md5\" , lines ) . hexdigest (), type = \"md5\" ) # simulate an incorrect MD5 if object_id == BAD_MD5 : checksum = Checksum ( hashlib . new ( \"md5\" , line ) . hexdigest (), type = \"md5\" ) # simulate an incorrect size if object_id == INCORRECT_SIZE : size_ += 1000 return DrsObject ( self_uri = object_id , size = size_ , # md5, etag, crc32c, trunc512, or sha1 checksums = [ checksum ], id = id_ , name = name_ , ) sign_url ( drs_object , verbose = False ) async Simulate url signing by waiting 1-3 seconds, return populated DrsObject Parameters: Name Type Description Default drs_object DrsObject required Returns: Type Description Optional [ DrsObject ] populated DrsObject Source code in drs_downloader/clients/mock.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 async def sign_url ( self , drs_object : DrsObject , verbose : bool = False ) -> Optional [ DrsObject ]: \"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject Args: drs_object: Returns: populated DrsObject \"\"\" # simulate a failed signature if drs_object . id == BAD_SIGNATURE : return None # here we sleep while the file is open and measure total files open fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"sign url\" ) self . statistics . set_max_files_open () fp . close () # provide expected result, e.g. X-Signature access_url = f \" { drs_object . self_uri } ?X-Signature= { uuid . uuid1 () } \" # place it in the right spot in the drs object drs_object . access_methods . append ( AccessMethod ( access_url = access_url , type = \"gs\" )) return drs_object manifest_all_ok ( number_of_object_ids ) Generate a test manifest, a tsv file with valid drs identifiers. Source code in drs_downloader/clients/mock.py 159 160 161 162 163 164 165 166 167 def manifest_all_ok ( number_of_object_ids ): \"\"\"Generate a test manifest, a tsv file with valid drs identifiers.\"\"\" ids_from_manifest = [ str ( uuid . uuid4 ()) for _ in range ( number_of_object_ids )] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \"drs:// { id_ } \\n \" ) tsv_file . close () return tsv_file manifest_bad_file_size () Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file. Source code in drs_downloader/clients/mock.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def manifest_bad_file_size (): \"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\" ids_from_manifest = [ \"drs://\" + str ( uuid . uuid4 ()), INCORRECT_SIZE , \"drs://\" + str ( uuid . uuid4 ()), ] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \" { id_ } \\n \" ) tsv_file . close () return tsv_file manifest_bad_id_for_download () Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file. Source code in drs_downloader/clients/mock.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def manifest_bad_id_for_download (): \"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\" ids_from_manifest = [ \"drs://\" + str ( uuid . uuid4 ()), \"drs://\" + str ( uuid . uuid4 ()), BAD_ID , \"drs://\" + str ( uuid . uuid4 ()), ] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \" { id_ } \\n \" ) tsv_file . close () return tsv_file","title":"mock"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient","text":"Bases: DrsClient Simulate responses from server. Source code in drs_downloader/clients/mock.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class MockDrsClient ( DrsClient ): \"\"\"Simulate responses from server.\"\"\" async def sign_url ( self , drs_object : DrsObject , verbose : bool = False ) -> Optional [ DrsObject ]: \"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject Args: drs_object: Returns: populated DrsObject \"\"\" # simulate a failed signature if drs_object . id == BAD_SIGNATURE : return None # here we sleep while the file is open and measure total files open fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"sign url\" ) self . statistics . set_max_files_open () fp . close () # provide expected result, e.g. X-Signature access_url = f \" { drs_object . self_uri } ?X-Signature= { uuid . uuid1 () } \" # place it in the right spot in the drs object drs_object . access_methods . append ( AccessMethod ( access_url = access_url , type = \"gs\" )) return drs_object async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Path : \"\"\"Actually download a part. Args: destination_path: drs_object: start: size: Returns: full path to that part. \"\"\" # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range length_ = size - start + 1 # logger.info((drs_object.name, start, length_)) # logger.error(\"ERROR1 %s\",drs_object) if BAD_ID in drs_object . self_uri : logger . warning ( f \"Mock bad id { drs_object . self_uri } \" ) drs_object . errors = [ \"Mock error BAD_ID\" ] return None with open ( Path ( os . getcwd (), f \" { drs_object . name } .golden\" ), \"rb\" ) as f : f . seek ( start ) data = f . read ( length_ ) ( fd , name ,) = tempfile . mkstemp ( prefix = f \" { drs_object . name } . { start } . { size } .\" , suffix = \".part\" , dir = str ( destination_path ), ) with os . fdopen ( fd , \"wb\" ) as fp : sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( data ) self . statistics . set_max_files_open () fp . close () return Path ( name ) async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Args: object_id: Returns: \"\"\" # \"\"\"Actually fetch the object. # # \"\"\" fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"get object\" ) self . statistics . set_max_files_open () fp . close () id_ = str ( uuid . uuid4 ()) name_ = f \"file- { id_ } .txt\" line = b \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \\n \" # noqa line_len = len ( line ) number_of_lines = int ( random . randint ( line_len , MAX_SIZE_OF_OBJECT ) / line_len ) lines = line * number_of_lines size_ = len ( lines ) # write it for testing destination_dir = Path ( os . getcwd ()) destination_dir . mkdir ( parents = True , exist_ok = True ) with open ( Path ( f \" { destination_dir } / { name_ } .golden\" ), \"wb\" ) as f : f . write ( lines ) checksum = Checksum ( hashlib . new ( \"md5\" , lines ) . hexdigest (), type = \"md5\" ) # simulate an incorrect MD5 if object_id == BAD_MD5 : checksum = Checksum ( hashlib . new ( \"md5\" , line ) . hexdigest (), type = \"md5\" ) # simulate an incorrect size if object_id == INCORRECT_SIZE : size_ += 1000 return DrsObject ( self_uri = object_id , size = size_ , # md5, etag, crc32c, trunc512, or sha1 checksums = [ checksum ], id = id_ , name = name_ , )","title":"MockDrsClient"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.download_part","text":"Actually download a part. Parameters: Name Type Description Default destination_path Path required drs_object DrsObject required start int required size int required Returns: Type Description Path full path to that part. Source code in drs_downloader/clients/mock.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Path : \"\"\"Actually download a part. Args: destination_path: drs_object: start: size: Returns: full path to that part. \"\"\" # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range length_ = size - start + 1 # logger.info((drs_object.name, start, length_)) # logger.error(\"ERROR1 %s\",drs_object) if BAD_ID in drs_object . self_uri : logger . warning ( f \"Mock bad id { drs_object . self_uri } \" ) drs_object . errors = [ \"Mock error BAD_ID\" ] return None with open ( Path ( os . getcwd (), f \" { drs_object . name } .golden\" ), \"rb\" ) as f : f . seek ( start ) data = f . read ( length_ ) ( fd , name ,) = tempfile . mkstemp ( prefix = f \" { drs_object . name } . { start } . { size } .\" , suffix = \".part\" , dir = str ( destination_path ), ) with os . fdopen ( fd , \"wb\" ) as fp : sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( data ) self . statistics . set_max_files_open () fp . close () return Path ( name )","title":"download_part()"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.get_object","text":"Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Parameters: Name Type Description Default object_id str required Source code in drs_downloader/clients/mock.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Fetch the object from repository DRS Service. See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject. Args: object_id: Returns: \"\"\" # \"\"\"Actually fetch the object. # # \"\"\" fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"get object\" ) self . statistics . set_max_files_open () fp . close () id_ = str ( uuid . uuid4 ()) name_ = f \"file- { id_ } .txt\" line = b \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \\n \" # noqa line_len = len ( line ) number_of_lines = int ( random . randint ( line_len , MAX_SIZE_OF_OBJECT ) / line_len ) lines = line * number_of_lines size_ = len ( lines ) # write it for testing destination_dir = Path ( os . getcwd ()) destination_dir . mkdir ( parents = True , exist_ok = True ) with open ( Path ( f \" { destination_dir } / { name_ } .golden\" ), \"wb\" ) as f : f . write ( lines ) checksum = Checksum ( hashlib . new ( \"md5\" , lines ) . hexdigest (), type = \"md5\" ) # simulate an incorrect MD5 if object_id == BAD_MD5 : checksum = Checksum ( hashlib . new ( \"md5\" , line ) . hexdigest (), type = \"md5\" ) # simulate an incorrect size if object_id == INCORRECT_SIZE : size_ += 1000 return DrsObject ( self_uri = object_id , size = size_ , # md5, etag, crc32c, trunc512, or sha1 checksums = [ checksum ], id = id_ , name = name_ , )","title":"get_object()"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.sign_url","text":"Simulate url signing by waiting 1-3 seconds, return populated DrsObject Parameters: Name Type Description Default drs_object DrsObject required Returns: Type Description Optional [ DrsObject ] populated DrsObject Source code in drs_downloader/clients/mock.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 async def sign_url ( self , drs_object : DrsObject , verbose : bool = False ) -> Optional [ DrsObject ]: \"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject Args: drs_object: Returns: populated DrsObject \"\"\" # simulate a failed signature if drs_object . id == BAD_SIGNATURE : return None # here we sleep while the file is open and measure total files open fp = tempfile . TemporaryFile () sleep_duration = random . randint ( 1 , 3 ) await asyncio . sleep ( delay = sleep_duration ) fp . write ( b \"sign url\" ) self . statistics . set_max_files_open () fp . close () # provide expected result, e.g. X-Signature access_url = f \" { drs_object . self_uri } ?X-Signature= { uuid . uuid1 () } \" # place it in the right spot in the drs object drs_object . access_methods . append ( AccessMethod ( access_url = access_url , type = \"gs\" )) return drs_object","title":"sign_url()"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_all_ok","text":"Generate a test manifest, a tsv file with valid drs identifiers. Source code in drs_downloader/clients/mock.py 159 160 161 162 163 164 165 166 167 def manifest_all_ok ( number_of_object_ids ): \"\"\"Generate a test manifest, a tsv file with valid drs identifiers.\"\"\" ids_from_manifest = [ str ( uuid . uuid4 ()) for _ in range ( number_of_object_ids )] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \"drs:// { id_ } \\n \" ) tsv_file . close () return tsv_file","title":"manifest_all_ok()"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_bad_file_size","text":"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file. Source code in drs_downloader/clients/mock.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def manifest_bad_file_size (): \"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\" ids_from_manifest = [ \"drs://\" + str ( uuid . uuid4 ()), INCORRECT_SIZE , \"drs://\" + str ( uuid . uuid4 ()), ] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \" { id_ } \\n \" ) tsv_file . close () return tsv_file","title":"manifest_bad_file_size()"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_bad_id_for_download","text":"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file. Source code in drs_downloader/clients/mock.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def manifest_bad_id_for_download (): \"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\" ids_from_manifest = [ \"drs://\" + str ( uuid . uuid4 ()), \"drs://\" + str ( uuid . uuid4 ()), BAD_ID , \"drs://\" + str ( uuid . uuid4 ()), ] tsv_file = tempfile . NamedTemporaryFile ( delete = False , mode = \"w\" ) tsv_file . write ( \"ga4gh_drs_uri \\n \" ) for id_ in ids_from_manifest : tsv_file . write ( f \" { id_ } \\n \" ) tsv_file . close () return tsv_file","title":"manifest_bad_id_for_download()"},{"location":"reference/clients/terra.html","text":"TerraDrsClient Bases: DrsClient Calls the terra DRS server. Source code in drs_downloader/clients/terra.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class TerraDrsClient ( DrsClient ): \"\"\" Calls the terra DRS server. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . endpoint = ( \"https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3\" ) self . token = None @dataclass class GcloudInfo ( object ): account : str project : str async def _get_auth_token ( self ) -> str : \"\"\"Get Google Cloud authentication token. User must run 'gcloud auth login' from the shell before starting this script. Returns: str: auth token see https://github.com/DataBiosphere/terra-notebook-utils/blob/b53bb8656d 502ecbdbfe9c5edde3fa25bd90bbf8/terra_notebook_utils/gs.py#L25-L42 \"\"\" creds , projects = google . auth . default () creds . refresh ( google . auth . transport . requests . Request ()) token = creds . token assert token , \"No token retrieved.\" logger . info ( \"gcloud token successfully fetched\" ) return creds async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: tries = 0 while True : try : headers = { \"Range\" : f \"bytes= { start } - { size } \" } file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( drs_object . access_methods [ 0 ] . access_url , ssl = context ) as request : if request . status > 399 : text = await request . content . read () request . raise_for_status () file = await aiofiles . open ( file_name , \"wb\" ) self . statistics . set_max_files_open () async for data in request . content . iter_any (): # uses less memory await file . write ( data ) await file . close () return Path ( file_name ) except aiohttp . ClientResponseError as f : tries += 1 if \"The provided token has expired\" in str ( text ): if verbose : logger . info ( f \"Error Text Body { str ( text ) } \" ) drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( f ) } \" ) return None time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . info ( f \"Error Text Body { str ( text ) } \" ) return None except Exception as e : tries += 1 time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . info ( f \"Miscellaneous Error { str ( text ) } \" ) drs_object . errors . append ( f \"NONRECOVERABLE ERROR { str ( e ) } \" ) return None async def sign_url ( self , drs_object : DrsObject , verbose : bool ) -> DrsObject : \"\"\"No-op. terra returns a signed url in `get_object`\"\"\" assert isinstance ( drs_object , DrsObject ), \"A DrsObject should be passed\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : drs_object . id , \"fields\" : [ \"accessUrl\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while ( True ): # This is here so that URL signing errors are caught they are rare, but I did capture one try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while ( True ): try : self . statistics . set_max_files_open () # these lines produced an error saying that the content.read() had already closed if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"accessUrl\" in resp , resp if resp [ \"accessUrl\" ] is None : account_command = \"gcloud config get-value account\" cmd = account_command . split ( \" \" ) account = subprocess . check_output ( cmd ) . decode ( \"ascii\" ) raise Exception ( f \"A valid URL was not returned from the server. \\ Please check the access for { account } \\n { resp } \" ) url_ = resp [ \"accessUrl\" ][ \"url\" ] type = \"none\" if \"storage.googleapis.com\" in url_ : type = \"gs\" drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = type ) ] return drs_object except ClientResponseError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"A file has failed the signing process, specifically { str ( e ) } \" ) if \"401\" in str ( e ): drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) except ClientConnectorError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : drs_object . errors . append ( str ( e )) if verbose : logger . error ( f \"retry failed in sign_url function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : object_id , \"fields\" : [ \"fileName\" , \"size\" , \"hashes\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while True : # this is here for the somewhat more common Martha disconnects. try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while True : try : self . statistics . set_max_files_open () if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) md5_ = resp [ \"hashes\" ][ \"md5\" ] size_ = resp [ \"size\" ] name_ = resp [ \"fileName\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , ) except ClientResponseError as e : tries += 1 if verbose : logger . info ( f \"Client Response Error { str ( text ) } \" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"retry failed in get_object function. \\ Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) except ClientConnectorError as e : tries += 1 if verbose : logger . info ( f \"ClientConnectorError: { str ( e ) } while fetching object information\" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"retry failed in get_object function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) get_object ( object_id , verbose = False ) async Sends a POST request for the signed URL, hash, and file size of a given DRS object. Parameters: Name Type Description Default object_id str DRS URI required Raises: Type Description Exception The request was rejected by the server Returns: Name Type Description DownloadURL DrsObject The downloadable bundle ready for async download Source code in drs_downloader/clients/terra.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : object_id , \"fields\" : [ \"fileName\" , \"size\" , \"hashes\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while True : # this is here for the somewhat more common Martha disconnects. try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while True : try : self . statistics . set_max_files_open () if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) md5_ = resp [ \"hashes\" ][ \"md5\" ] size_ = resp [ \"size\" ] name_ = resp [ \"fileName\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , ) except ClientResponseError as e : tries += 1 if verbose : logger . info ( f \"Client Response Error { str ( text ) } \" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"retry failed in get_object function. \\ Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) except ClientConnectorError as e : tries += 1 if verbose : logger . info ( f \"ClientConnectorError: { str ( e ) } while fetching object information\" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"retry failed in get_object function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) sign_url ( drs_object , verbose ) async No-op. terra returns a signed url in get_object Source code in drs_downloader/clients/terra.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def sign_url ( self , drs_object : DrsObject , verbose : bool ) -> DrsObject : \"\"\"No-op. terra returns a signed url in `get_object`\"\"\" assert isinstance ( drs_object , DrsObject ), \"A DrsObject should be passed\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : drs_object . id , \"fields\" : [ \"accessUrl\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while ( True ): # This is here so that URL signing errors are caught they are rare, but I did capture one try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while ( True ): try : self . statistics . set_max_files_open () # these lines produced an error saying that the content.read() had already closed if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"accessUrl\" in resp , resp if resp [ \"accessUrl\" ] is None : account_command = \"gcloud config get-value account\" cmd = account_command . split ( \" \" ) account = subprocess . check_output ( cmd ) . decode ( \"ascii\" ) raise Exception ( f \"A valid URL was not returned from the server. \\ Please check the access for { account } \\n { resp } \" ) url_ = resp [ \"accessUrl\" ][ \"url\" ] type = \"none\" if \"storage.googleapis.com\" in url_ : type = \"gs\" drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = type ) ] return drs_object except ClientResponseError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"A file has failed the signing process, specifically { str ( e ) } \" ) if \"401\" in str ( e ): drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) except ClientConnectorError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : drs_object . errors . append ( str ( e )) if verbose : logger . error ( f \"retry failed in sign_url function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], )","title":"terra"},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient","text":"Bases: DrsClient Calls the terra DRS server. Source code in drs_downloader/clients/terra.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class TerraDrsClient ( DrsClient ): \"\"\" Calls the terra DRS server. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . endpoint = ( \"https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3\" ) self . token = None @dataclass class GcloudInfo ( object ): account : str project : str async def _get_auth_token ( self ) -> str : \"\"\"Get Google Cloud authentication token. User must run 'gcloud auth login' from the shell before starting this script. Returns: str: auth token see https://github.com/DataBiosphere/terra-notebook-utils/blob/b53bb8656d 502ecbdbfe9c5edde3fa25bd90bbf8/terra_notebook_utils/gs.py#L25-L42 \"\"\" creds , projects = google . auth . default () creds . refresh ( google . auth . transport . requests . Request ()) token = creds . token assert token , \"No token retrieved.\" logger . info ( \"gcloud token successfully fetched\" ) return creds async def download_part ( self , drs_object : DrsObject , start : int , size : int , destination_path : Path , verbose : bool = False ) -> Optional [ Path ]: tries = 0 while True : try : headers = { \"Range\" : f \"bytes= { start } - { size } \" } file_name = destination_path / f \" { drs_object . name } . { start } . { size } .part\" context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : async with session . get ( drs_object . access_methods [ 0 ] . access_url , ssl = context ) as request : if request . status > 399 : text = await request . content . read () request . raise_for_status () file = await aiofiles . open ( file_name , \"wb\" ) self . statistics . set_max_files_open () async for data in request . content . iter_any (): # uses less memory await file . write ( data ) await file . close () return Path ( file_name ) except aiohttp . ClientResponseError as f : tries += 1 if \"The provided token has expired\" in str ( text ): if verbose : logger . info ( f \"Error Text Body { str ( text ) } \" ) drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( f ) } \" ) return None time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . info ( f \"Error Text Body { str ( text ) } \" ) return None except Exception as e : tries += 1 time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . info ( f \"Miscellaneous Error { str ( text ) } \" ) drs_object . errors . append ( f \"NONRECOVERABLE ERROR { str ( e ) } \" ) return None async def sign_url ( self , drs_object : DrsObject , verbose : bool ) -> DrsObject : \"\"\"No-op. terra returns a signed url in `get_object`\"\"\" assert isinstance ( drs_object , DrsObject ), \"A DrsObject should be passed\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : drs_object . id , \"fields\" : [ \"accessUrl\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while ( True ): # This is here so that URL signing errors are caught they are rare, but I did capture one try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while ( True ): try : self . statistics . set_max_files_open () # these lines produced an error saying that the content.read() had already closed if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"accessUrl\" in resp , resp if resp [ \"accessUrl\" ] is None : account_command = \"gcloud config get-value account\" cmd = account_command . split ( \" \" ) account = subprocess . check_output ( cmd ) . decode ( \"ascii\" ) raise Exception ( f \"A valid URL was not returned from the server. \\ Please check the access for { account } \\n { resp } \" ) url_ = resp [ \"accessUrl\" ][ \"url\" ] type = \"none\" if \"storage.googleapis.com\" in url_ : type = \"gs\" drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = type ) ] return drs_object except ClientResponseError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"A file has failed the signing process, specifically { str ( e ) } \" ) if \"401\" in str ( e ): drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) except ClientConnectorError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : drs_object . errors . append ( str ( e )) if verbose : logger . error ( f \"retry failed in sign_url function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : object_id , \"fields\" : [ \"fileName\" , \"size\" , \"hashes\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while True : # this is here for the somewhat more common Martha disconnects. try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while True : try : self . statistics . set_max_files_open () if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) md5_ = resp [ \"hashes\" ][ \"md5\" ] size_ = resp [ \"size\" ] name_ = resp [ \"fileName\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , ) except ClientResponseError as e : tries += 1 if verbose : logger . info ( f \"Client Response Error { str ( text ) } \" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"retry failed in get_object function. \\ Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) except ClientConnectorError as e : tries += 1 if verbose : logger . info ( f \"ClientConnectorError: { str ( e ) } while fetching object information\" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"retry failed in get_object function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], )","title":"TerraDrsClient"},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient.get_object","text":"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Parameters: Name Type Description Default object_id str DRS URI required Raises: Type Description Exception The request was rejected by the server Returns: Name Type Description DownloadURL DrsObject The downloadable bundle ready for async download Source code in drs_downloader/clients/terra.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 async def get_object ( self , object_id : str , verbose : bool = False ) -> DrsObject : \"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object. Args: object_id (str): DRS URI Raises: Exception: The request was rejected by the server Returns: DownloadURL: The downloadable bundle ready for async download \"\"\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : object_id , \"fields\" : [ \"fileName\" , \"size\" , \"hashes\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while True : # this is here for the somewhat more common Martha disconnects. try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while True : try : self . statistics . set_max_files_open () if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) md5_ = resp [ \"hashes\" ][ \"md5\" ] size_ = resp [ \"size\" ] name_ = resp [ \"fileName\" ] return DrsObject ( self_uri = object_id , size = size_ , checksums = [ Checksum ( checksum = md5_ , type = \"md5\" )], id = object_id , name = name_ , ) except ClientResponseError as e : tries += 1 if verbose : logger . info ( f \"Client Response Error { str ( text ) } \" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"retry failed in get_object function. \\ Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], ) except ClientConnectorError as e : tries += 1 if verbose : logger . info ( f \"ClientConnectorError: { str ( e ) } while fetching object information\" ) time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"retry failed in get_object function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = object_id , id = object_id , checksums = [], size = 0 , name = None , errors = [ str ( e )], )","title":"get_object()"},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient.sign_url","text":"No-op. terra returns a signed url in get_object Source code in drs_downloader/clients/terra.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def sign_url ( self , drs_object : DrsObject , verbose : bool ) -> DrsObject : \"\"\"No-op. terra returns a signed url in `get_object`\"\"\" assert isinstance ( drs_object , DrsObject ), \"A DrsObject should be passed\" if ( self . token is None or ( self . token . expired and self . token . expiry is not None )): if verbose : logger . info ( \"fetching new token\" ) self . token = await self . _get_auth_token () if verbose : logger . info ( f \"status of token expiration { self . token . expiry } \" ) data = { \"url\" : drs_object . id , \"fields\" : [ \"accessUrl\" ]} headers = { \"authorization\" : \"Bearer \" + self . token . token , \"content-type\" : \"application/json\" , } tries = 0 context = ssl . create_default_context ( cafile = certifi . where ()) async with aiohttp . ClientSession ( headers = headers ) as session : while ( True ): # This is here so that URL signing errors are caught they are rare, but I did capture one try : async with session . post ( url = self . endpoint , json = data , ssl = context ) as response : while ( True ): try : self . statistics . set_max_files_open () # these lines produced an error saying that the content.read() had already closed if response . status > 399 : text = await response . content . read () response . raise_for_status () resp = await response . json ( content_type = None ) assert \"accessUrl\" in resp , resp if resp [ \"accessUrl\" ] is None : account_command = \"gcloud config get-value account\" cmd = account_command . split ( \" \" ) account = subprocess . check_output ( cmd ) . decode ( \"ascii\" ) raise Exception ( f \"A valid URL was not returned from the server. \\ Please check the access for { account } \\n { resp } \" ) url_ = resp [ \"accessUrl\" ][ \"url\" ] type = \"none\" if \"storage.googleapis.com\" in url_ : type = \"gs\" drs_object . access_methods = [ AccessMethod ( access_url = url_ , type = type ) ] return drs_object except ClientResponseError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : if verbose : logger . error ( f \"value of text error { str ( text ) } \" ) logger . error ( f \"A file has failed the signing process, specifically { str ( e ) } \" ) if \"401\" in str ( e ): drs_object . errors . append ( f \"RECOVERABLE in AIOHTTP { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], ) except ClientConnectorError as e : tries += 1 if self . token . expired and self . token . expiry is not None : self . token = await self . _get_auth_token () time . sleep (( random . randint ( 0 , 1000 ) / 1000 ) + 2 ** tries ) if tries > 2 : drs_object . errors . append ( str ( e )) if verbose : logger . error ( f \"retry failed in sign_url function. Exiting with error status: { str ( e ) } \" ) return DrsObject ( self_uri = \"\" , id = \"\" , checksums = [], size = 0 , name = None , errors = [ f \"error: { str ( text ) } \" ], )","title":"sign_url()"}]}