{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"DRS Downloader","text":"<p>A file download tool for AnVIL/TDR data identified by DRS URIs</p> <ul> <li>Installation</li> <li>Checksum Verification</li> <li>Running the Executable</li> <li>Requirements<ul> <li>Authentication</li> </ul> </li> <li>Usage</li> <li>Quick Start<ul> <li>Arguments</li> </ul> </li> <li>Basic Example</li> <li>Example with a Different Header Value</li> <li>Help/Additional Options</li> <li>Credits</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"Operating System DRS Downloader Checksum macOS drs_downloader.pkg checksums.txt Linux drs_downloader checksums.txt Windows drs_downloader.exe checksums.txt <p>Download the latest <code>drs_downloader</code> zip file for your operating system. Unzipping the downloaded file will provide a <code>drs_downloader</code> executable file that can be run directly.</p> Supported OS Versions Operating System Supported Versions macOS 12 (Monterey), 13 (Ventura) Linux Ubuntu 22.04 (Jammy Jellyfish) Windows Windows 11 <p>Notes:</p> <ul> <li>Testing was done on hardware running macOS Monterey and Ventura (Apple Silicon M1 chips), with Windows and Linux emulation through UTM.</li> <li>Due to hardware limitations with the ARM M1 chips, Windows 10 was not included in the list of tested operated systems as Microsoft does not currently provide a public Windows 10 ARM build.</li> <li>Ubuntu 20.04 (Focal Fossa) uses version 2.31 of the GNU C Library which appears to be incompatible with Python 3.10 requirement of version 2.35.</li> </ul>"},{"location":"index.html#checksum-verification","title":"Checksum Verification","text":"<p>In order to verify that the downloaded file can be trusted checksums are provided in <code>checksums.txt</code>. See below for examples of how to use this file.</p> Successful Verification  To verify the integrity of the binaries on macOS run the following command in the same directory as the downloaded file:   <pre><code>$ shasum -c checksums.txt --ignore-missing\ndrs_downloader.pkg: OK\n</code></pre>   If the `shasum` command outputs `OK` than the verification was successful and the executable can be trusted.   Unsuccessful Verification  Alternatively if the commad outputs `FAILED` than the checksum did not match and the binary should not be run.   <pre><code>$ shasum -c checksums.txt --ignore-missing\ndrs_downloader.pkg: FAILED\nshasum: WARNING: 1 computed checksum did NOT match\nshasum: checksums.txt: no file was verified\n</code></pre>   In such a case please reach out to the contributors for assistance."},{"location":"index.html#running-the-executable","title":"Running the Executable","text":"<p>For Linux to run the exe you will have to grant the file higher permissions. you can do this by running:</p> <pre><code>chmod +x [filename]\n</code></pre>"},{"location":"index.html#requirements","title":"Requirements","text":"<p>The downloader requires that a Google Cloud project be designated as the billing project. In order for the downloader to authenticate and set the desired billing project the gcloud CLI tool must first be installed:</p> <ul> <li>gcloud CLI \u2014 used to authenticate the downloader and set the billing project.</li> <li>Python \u2014 required for gcloud CLI functionality.</li> </ul>"},{"location":"index.html#authentication","title":"Authentication","text":"<p>Upon running the following <code>gcloud</code> command a browser window will open in which you may choose the Google account used for the billing project:</p> <pre><code>$ gcloud auth application-default login\nYour browser has been opened to visit:\n\n    https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=...\n\n\n\nYou are now logged in as [rosalind@ohsu.edu].\nYour current project is [terra-314159].  You can change this setting by running:\n  $ gcloud config set project PROJECT_ID\n</code></pre> <p>To change the billing project at any time you may use either the <code>$ gcloud config set project PROJECT_ID</code> command or the built-in <code>drs-downloader</code> command:</p> <pre><code>$ drs_downloader terra --project-id Project ID&gt;\n</code></pre>"},{"location":"index.html#usage","title":"Usage","text":""},{"location":"index.html#quick-start","title":"Quick Start","text":"<pre><code>$ drs_downloader terra -m &lt;manifest file&gt; -d &lt;destination directory&gt;\n</code></pre>"},{"location":"index.html#arguments","title":"Arguments","text":"<p><code>-s, --silent</code></p> <p>Disables all output to the terminal during and after downloading.</p> <p><code>-d, --destination_dir TEXT</code></p> <p>The directory or folder to download the DRS Objects to. Defaults to <code>/tmp/testing</code> if no value is provided.</p> <p><code>-m, --manifest_path TEXT</code></p> <p>The manifest file that contains the DRS Objects to be downloaded. Typically a TSV file with one row per DRS Object.</p> <p><code>--drs_header TEXT</code></p> <p>The value of the column in the manifest file containing the DRS Object IDs. Defaults to <code>pfb:ga4gh_drs_uri</code> if no value is provided.</p> <p><code>--duplicate</code></p> <p>downloads files and saves them into the specified directory even if there is already files with the same name already in the directory. Numbered naming is used to specify the order of duplicates downloaded to the directory. For example: 1st -&gt; original_file 2nd -&gt; original_file(1) 3rd-&gt; original_file(2) ...</p>"},{"location":"index.html#basic-example","title":"Basic Example","text":"<p>The below command is a basic example of how to structure a download command with all of the required arguments. It uses:</p> <ul> <li>a manifest file called <code>terra-data.tsv</code> with 10 DRS Objects</li> <li>a DRS header value of <code>pfb:ga4gh_drs_uri</code> within the manifest file to reference the DRS Objects. It can be omitted since this is the default value used by the downloader.</li> <li>a download directory called <code>DATA</code> as the destination</li> </ul> <pre><code>$ drs_downloader terra -m tests/fixtures/manifest/terra-data.tsv -d DATA\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00&lt;00:00, 56148.65it/s]\n\n2022-11-21 16:56:49,595 ('HG03873.final.cram.crai', 'OK', 1351946, 1)\n2022-11-21 16:56:49,595 ('HG04209.final.cram.crai', 'OK', 1338980, 1)\n2022-11-21 16:56:49,595 ('HG02142.final.cram.crai', 'OK', 1405543, 1)\n2022-11-21 16:56:49,595 ('HG01552.final.cram.crai', 'OK', 1296198, 1)\n2022-11-21 16:56:49,595 ('NA18613.final.cram.crai', 'OK', 1370106, 1)\n2022-11-21 16:56:49,595 ('HG00536.final.cram.crai', 'OK', 1244278, 1)\n2022-11-21 16:56:49,595 ('HG02450.final.cram.crai', 'OK', 1405458, 1)\n2022-11-21 16:56:49,595 ('NA20525.final.cram.crai', 'OK', 1337382, 1)\n2022-11-21 16:56:49,595 ('NA20356.final.cram.crai', 'OK', 1368064, 1)\n2022-11-21 16:56:49,595 ('HG00622.final.cram.crai', 'OK', 1254920, 1)\n2022-11-21 16:56:49,595 ('done', 'statistics.max_files_open', 37)\n</code></pre> <p>After the download completes we can look in the <code>DATA</code> directory to confirm that all 10 DRS Objects have been downloaded:</p> <pre><code>$ ls ./DATA\nHG00536.final.cram.crai HG01552.final.cram.crai\nHG02450.final.cram.crai HG04209.final.cram.crai\nNA20356.final.cram.crai HG00622.final.cram.crai\nHG02142.final.cram.crai HG03873.final.cram.crai\nNA18613.final.cram.crai NA20525.final.cram.crai\n</code></pre>"},{"location":"index.html#example-with-a-different-header-value","title":"Example with a Different Header Value","text":"<p>Let's take a look at different manifest file called <code>terra-different-header.tsv</code>. Namely the DRS header value is now <code>drs_uri</code> so we will need to tell the downloader which column to find the DRS URI's in the manifest with the <code>--drs_header</code> flag:</p> <pre><code>drs_downloader terra -m tests/fixtures/manifests/terra-different-header.tsv -d DATA --drs_header drs_uri\n</code></pre> <p>This will download the DRS Objects specified in the <code>drs_uri</code> column into the <code>DATA</code> directory just as before.</p>"},{"location":"index.html#helpadditional-options","title":"Help/Additional Options","text":"<p>To see all available flags run the <code>help</code> command:</p> <pre><code>$ drs_downloader terra --help\n\nUsage: drs_download terra [OPTIONS]\n\n  Copy files from terra.bio\n\nOptions:\n  -s, --silent                Display nothing.\n  -d, --destination_dir TEXT  Destination directory.  [default: /tmp/testing]\n  -m, --manifest_path TEXT    Path to manifest tsv.\n  --duplicate                 allow duplicate downloads with same file name\n  --drs_header TEXT           The column header in the TSV file associated\n                              with the DRS URIs.Example: pfb:ga4gh_drs_uri\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"index.html#credits","title":"Credits","text":"<p>This project is developed in partnership between The AnVIL Project, the Broad Institute, and the Ellrott Lab at Oregon Health &amp; Science University. Development is lead by Brian Walsh with contributions from Matthew Peterkort and Liam Beckman. Special thanks to Michael Baumann at the Broad Institute for guidance and development recommendations.</p>"},{"location":"development.html","title":"Development","text":"<p>To get ready for development first get the code:</p> <pre><code>$ git clone https://github.com/anvilproject/drs_downloader\n$ cd drs_downloader\n</code></pre> <p>Then create and activate a virtual environment using <code>Python3.10</code>:</p> <pre><code>$ python3.10 -m venv venv\n$ . venv/bin/activate\n$ pip install -r requirements.txt -r requirements-dev.txt\n</code></pre>"},{"location":"development.html#terra-authentication","title":"Terra Authentication","text":"<p>In order for the downloader to work, you will need to install Google gcloud CLI on your local machine. https://cloud.google.com/sdk/docs/install</p> <p>Next, you must connect the google account that your Terra account connected to gcloud. This is done with gcloud auth login:</p> <pre><code>$ gcloud auth login\n</code></pre> <p>You need to have a terra project that is set up for billing. Once you get one, go to your terra workspaces page: https://anvil.terra.bio/#workspaces/</p> <p>Click on the project that you want to bill to. On the righthand corner of the screen click on Cloud Information heading.</p> <p>Copy and paste the Google Project Id field into the below command:</p> <pre><code>$ gcloud config set project &lt;project ID&gt;\n</code></pre> <p>Next, you need to link your Google account to the location where the DRS URIs will download from. This is endpoint specific.</p> <p>Go to anvil.terra.bio profile page</p> <p>If you are logging into bio data catalyst do the following:</p> <ol> <li>Right click on the log in/renew button.</li> <li>Select copy url.</li> <li>Copy this link in another tab but instead of pressing enter go to the end of the URL that was copied and change the suffix of the URL from <code>=[old suffix]</code> to <code>=google</code></li> </ol> <p>If your URIs are not from bio data catalyst then authenticate with your Terra Linked Google account on the other sites.</p> <p>Now run <code>gcloud auth print-access-token</code>. This should return a long string of letters an numbers. If it doesn't then your Terra google account is probably not linked with your gcloud account.</p> <p>To test that this setup returns signed URLs copy and paste the below curl command into your terminal, but instead of running it replace [URI] with a DRS uri that belongs to a small file from your TSV file. By running this in terminal you should get back a signed URL that you can copy and paste into your browser to download a file.</p> <pre><code>$ curl --request POST  --url https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3  --header \"authorization: Bearer $(gcloud auth print-access-token)\"  --header 'content-type: application/json'  --data '{ \"url\": \"[URI]\", \"fields\": [\"fileName\", \"size\", \"hashes\", \"accessUrl\"] }'\n</code></pre> <p>If you can run the above command with your own DRS URI than you are setup to run the command line tool.</p> <p>Now you should be ready to start coding and testing!</p>"},{"location":"development.html#gen3-authentication","title":"Gen3 Authentication","text":""},{"location":"development.html#tests","title":"Tests","text":"<p>All tests and test files are stored in the <code>tests</code> directory. Pytest is used as the testing framework. To run all tests with a coverage report run <code>pytest</code> with the <code>--cov=tests</code> flag:</p> <pre><code>$ pytest --cov=tests\n\n========================= test session starts =========================\nplatform darwin -- Python 3.9.4, pytest-7.2.0, pluggy-1.0.0\nrootdir: /Users/beckmanl/code/drs_downloader, configfile: pyproject.toml\nplugins: cov-4.0.0, anyio-3.6.2\ncollected 4 items\n\ntests/unit/test_main.py ...                                       [ 75%]\ntests/unit/test_basic_cli.py .                                    [100%]\n\n---------- coverage: platform darwin, python 3.9.4-final-0 -----------\nName                           Stmts   Miss  Cover\n--------------------------------------------------\ntests/unit/test_main.py                41      0   100%\ntests/unit/test_basic_cli.py       3      0   100%\n--------------------------------------------------\nTOTAL                             44      0   100%\n\n\n========================== 4 passed in 14.68s ==========================\n</code></pre>"},{"location":"development.html#contributing","title":"Contributing","text":"<p>Pull requests, issues, and feature requests welcome. Please reach out if you have questions setting the development environment!</p>"},{"location":"development.html#project-layout","title":"Project layout","text":"<pre><code>\u250c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 index.md         # The documentation homepage\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 drs_downloader       # Source directory\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 clients\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 manager.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 requirements-dev.txt # Installation dependencies\n\u251c\u2500\u2500 requirements.txt     # Development dependencies\n\u251c\u2500\u2500 setup.py             # Setuptools file, used by Pyinstaller and pip\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 fixtures         # Test manifest files\n    \u2514\u2500\u2500 unit             # Unit tests\n</code></pre>"},{"location":"development.html#useful-packages","title":"Useful Packages","text":"<p>Here are a few packages we've found useful for this project:</p> <p>Pip Packages - pipdeptree - Flake8 - autopep8</p> <p>Git Extensions - pre-commit - git-secrets</p> <p>VS Code Extensions - autoDocstring - Markdown All in One - Python</p>"},{"location":"testing.html","title":"Testing Instructions","text":"<p>Thank you for trying out the DRS Downloader! This project was developed by our team of developers here at OHSU and the Broad Institute for use in The AnVIL ecosystem. We are excited to hear any feedback or suggestions based off of your experience with it! Let's get started.</p>"},{"location":"testing.html#installation","title":"Installation","text":"<p>First navigate to the documentation page here and select the \"drs_downloader\" link for your operating system. You may also choose to download the checksums file in order to verify the file integrity (instructions on how to do so may be found here).</p> <p>We'll be using this manifest file for the downloading, but feel free to substitute it for any valid manifest file as well. The one we link to includes a variety of file types and sizes to test against our program.</p> <p>With the <code>drs_downloader</code> program and manifest file in place we're now ready to authenticate with Google. In order to do so we'll use the the <code>gcloud</code> CLI program provided by Google. Instructions for the installation of <code>gcloud</code> may be found here and are replicated below: - Download the <code>tar.gz</code> archive for your OS - Extract the archive to your home directory - Run the install script with <code>./google-cloud-sdk/install.sh</code> - Log in with the Google account you want to use for billing with <code>gcloud auth application-default login</code>. This will open a browser window with a Google login prompt.</p>"},{"location":"testing.html#use","title":"Use","text":"<p>Now that we've successfully authenticated with Google we're ready to start the downloading! Verify that the DRS downloader is ready to use by entering <code>drs_downloader terra --help</code>. This should output all available flags and options for the <code>terra</code> download function.</p> <p>Now let's start the download process! We'll specify our manifest file and the destination we wish to download to, in this the <code>/tmp</code> directory:</p> <pre><code>drs_downloader terra --manifest_path terra-data.tsv --destination_dir /tmp\n</code></pre> <p>This command will output the progress of the download process. Upon completion we can verify that the files were successfully downloaded by looking at the destination directory.</p>"},{"location":"reference/index.html","title":"drs_downloader","text":"<p>Main module for the DRS downloader package.</p> <p>Configuration options allow for optimizing the download process:</p> <ul> <li>Object retrievers: The number of DRS objects are retrieved in a given batch.</li> <li>Object signers: The number of DRS objects signed in a given batch.</li> <li>Downloaders: The number of simultaneous downloads to start in a given batch.</li> <li>Part handlers: The number of parts to download at a given time.</li> <li>Part size: size in bytes for each downloadable part of a given DRS object.</li> </ul>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>drs_downloader<ul> <li>cli</li> <li>clients<ul> <li>gen3</li> <li>mock</li> <li>terra</li> </ul> </li> <li>manager</li> <li>models</li> <li>upgrader</li> </ul> </li> </ul>"},{"location":"reference/cli.html","title":"cli","text":""},{"location":"reference/cli.html#drs_downloader.cli.cli","title":"<code>cli()</code>","text":"<p>Copy DRS objects from the cloud to your local system .</p> Source code in <code>drs_downloader/cli.py</code> <pre><code>@click.group()\ndef cli():\n\"\"\"Copy DRS objects from the cloud to your local system .\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cli.html#drs_downloader.cli.gen3","title":"<code>gen3(verbose, destination_dir, manifest_path, drs_column_name, api_key_path, endpoint, duplicate)</code>","text":"<p>Copy files from gen3 server.</p> Source code in <code>drs_downloader/cli.py</code> <pre><code>@cli.command()\n@click.option(\n    \"--verbose\",\n    \"-v\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Display every logger\",\n)\n@click.option(\n    \"--destination-dir\",\n    \"-d\",\n    show_default=True,\n    default=os.getcwd(),\n    help=\"Destination directory.\",\n)\n@click.option(\"--manifest-path\", \"-m\", show_default=True, help=\"Path to manifest tsv.\")\n@click.option(\n    \"--drs-column-name\",\n    default=\"ga4gh_drs_uri\",\n    show_default=True,\n    help=\"The column header in the TSV file associated with the DRS URIs.\"\n    \"Example: pfb:ga4gh_drs_uri\",\n)\n@click.option(\"--api-key-path\", show_default=True, help=\"Gen3 credentials file\")\n@click.option(\"--endpoint\", show_default=True, required=True, help=\"Gen3 endpoint\")\n@click.option(\n    \"--duplicate\",\n    default=False,\n    is_flag=True,\n    show_default=True,\n    help=\"This flag is used to specify wether \\\n    or not to download the file again if it already exists in the directory\"\n    \"Example: True\",\n)\ndef gen3(\n    verbose: bool,\n    destination_dir: str,\n    manifest_path: str,\n    drs_column_name: str,\n    api_key_path: str,\n    endpoint: str,\n    duplicate: bool,\n):\n\"\"\"Copy files from gen3 server.\"\"\"\n    # read from manifest\n    ids_from_manifest = _extract_tsv_info(Path(manifest_path), drs_column_name)\n\n    _perform_downloads(\n        destination_dir,\n        Gen3DrsClient(api_key_path=api_key_path, endpoint=endpoint),\n        ids_from_manifest,\n        verbose,\n        duplicate=duplicate,\n    )\n</code></pre>"},{"location":"reference/cli.html#drs_downloader.cli.mock","title":"<code>mock(verbose, destination_dir, manifest_path, drs_column_name, duplicate)</code>","text":"<p>Generate test files locally, without the need for server.</p> Source code in <code>drs_downloader/cli.py</code> <pre><code>@cli.command()\n@click.option(\n    \"--verbose\",\n    \"-v\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Display every logger\",\n)\n@click.option(\n    \"--destination-dir\",\n    \"-d\",\n    show_default=True,\n    default=os.getcwd(),\n    help=\"Destination directory.\",\n)\n@click.option(\"--manifest-path\", \"-m\", show_default=True, help=\"Path to manifest tsv.\")\n@click.option(\n    \"--drs-column-name\",\n    default=\"ga4gh_drs_uri\",\n    show_default=True,\n    help=\"The column header in the TSV file associated with the DRS URIs.\"\n    \"Example: pfb:ga4gh_drs_uri\",\n)\n@click.option(\n    \"--duplicate\",\n    default=False,\n    is_flag=True,\n    show_default=True,\n    help=\"This flag is used to specify wether \\\n    or not to download the file again if it already exists in the directory\"\n    \"Example: True\",\n)\ndef mock(\n    verbose: bool,\n    destination_dir: str,\n    manifest_path: str,\n    drs_column_name: str,\n    duplicate: bool,\n):\n\"\"\"Generate test files locally, without the need for server.\"\"\"\n\n    #\n    # get ids from manifest\n    ids_from_manifest = _extract_tsv_info(Path(manifest_path), drs_column_name)\n\n    # perform downloads with a mock drs client\n    _perform_downloads(\n        destination_dir, MockDrsClient(), ids_from_manifest, verbose, duplicate=duplicate\n    )\n</code></pre>"},{"location":"reference/cli.html#drs_downloader.cli.pretty_size","title":"<code>pretty_size(bytes)</code>","text":"<p>Integer -&gt; human readable Data Size Pretty Printer</p> Source code in <code>drs_downloader/cli.py</code> <pre><code>def pretty_size(bytes):\n\"\"\"Integer -&gt; human readable Data Size Pretty Printer\"\"\"\n    assert (bytes and bytes &gt; 0), f\"ERROR, The total download size {bytes} is Zero or None\"\n    units = [\n        (1 &lt;&lt; 50, \" PB\"),\n        (1 &lt;&lt; 40, \" TB\"),\n        (1 &lt;&lt; 30, \" GB\"),\n        (1 &lt;&lt; 20, \" MB\"),\n        (1 &lt;&lt; 10, \" KB\"),\n        (1, (\" bytes\")),\n    ]\n    if (bytes/1000000000 &lt; 1):\n        price = 0.1\n    else:\n        price = '%.2f' % ((bytes/1000000000) * 0.1)\n\n    for factor, suffix in units:\n        if bytes &gt;= factor:\n            break\n    amount = int(bytes / factor)\n    return str(amount) + suffix, price\n</code></pre>"},{"location":"reference/cli.html#drs_downloader.cli.terra","title":"<code>terra(verbose, destination_dir, manifest_path, drs_column_name, duplicate)</code>","text":"<p>Copy files from terra.bio</p> Source code in <code>drs_downloader/cli.py</code> <pre><code>@cli.command()\n@click.option(\n    \"--verbose\",\n    \"-v\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Display every logger\",\n)\n@click.option(\n    \"--destination-dir\",\n    \"-d\",\n    show_default=True,\n    default=os.getcwd(),\n    help=\"Destination directory.\",\n)\n@click.option(\"--manifest-path\", \"-m\", show_default=True, help=\"Path to manifest tsv.\")\n@click.option(\n    \"--drs-column-name\",\n    default=None,\n    help=\"The column header in the TSV file associated with the DRS URIs.\"\n    \"Example: pfb:ga4gh_drs_uri\",\n)\n@click.option(\n    \"--duplicate\",\n    default=False,\n    is_flag=True,\n    show_default=True,\n    help=\"This flag is used to specify wether \\\n    or not to download the file again if it already exists in the directory\"\n    \"Example: True\",\n)\ndef terra(\n    verbose: bool,\n    destination_dir: str,\n    manifest_path: str,\n    drs_column_name: str,\n    duplicate: bool,\n):\n\"\"\"Copy files from terra.bio\"\"\"\n\n    # get ids from manifest\n    ids_from_manifest = _extract_tsv_info(Path(manifest_path), drs_column_name)\n\n    # perform downloads with a terra drs client\n    _perform_downloads(\n        destination_dir,\n        TerraDrsClient(),\n        ids_from_manifest=ids_from_manifest,\n        verbose=verbose,\n        duplicate=duplicate,\n    )\n</code></pre>"},{"location":"reference/manager.html","title":"manager","text":""},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager","title":"<code>DrsAsyncManager</code>","text":"<p>             Bases: <code>DrsManager</code></p> <p>Manage DRSClient workload with asyncio threads, display progress.</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>class DrsAsyncManager(DrsManager):\n\"\"\"Manage DRSClient workload with asyncio threads, display progress.\"\"\"\n\n    def __init__(\n        self,\n        drs_client: DrsClient,\n        show_progress: bool = True,\n        part_size: int = DEFAULT_PART_SIZE,\n        max_simultaneous_object_retrievers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS,\n        max_simultaneous_downloaders=DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS,\n        max_simultaneous_part_handlers=DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS,\n        max_simultaneous_object_signers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS,\n    ):\n\"\"\"\n\n        Args:\n            drs_client: the client that will interact with server\n            show_progress: show progress bars\n            part_size: tweak to optimize workload\n            max_simultaneous_object_retrievers: tweak to optimize workload\n            max_simultaneous_downloaders: tweak to optimize workload\n            max_simultaneous_part_handlers: tweak to optimize workload\n        \"\"\"\n        # \"\"\"Implements abstract constructor.\"\"\"\n        super().__init__(drs_client=drs_client)\n        self.max_simultaneous_object_retrievers = max_simultaneous_object_retrievers\n        self.max_simultaneous_object_signers = max_simultaneous_object_signers\n        self.max_simultaneous_downloaders = max_simultaneous_downloaders\n        self.max_simultaneous_part_handlers = max_simultaneous_part_handlers\n        self.disable = not show_progress\n        self.part_size = part_size\n\n    @staticmethod\n    def _parts_generator(\n        size: int, start: int = 0, part_size: int = None\n    ) -&gt; Iterator[Tuple[int, int]]:\n\"\"\"Determine the start,size for each part\n\n        Args:\n            size: size of file\n            start: offset into file 0 based\n            part_size: desired part size\n\n        Returns:\n            iterator of tuple start, size\n        \"\"\"\n        while size - start &gt; part_size:\n            yield start, start + part_size\n            start += part_size + 1\n            # start += part_size\n        yield start, size\n\n    async def wait_till_completed(self, tasks, err_function_msg):\n        drs_objects_with_signed_urls = []\n        while tasks:\n            done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_EXCEPTION)\n            for t in tqdm.tqdm(done, total=len(tasks),\n                               desc=f\"retrieving {err_function_msg} information\",\n                               disable=self.disable):\n                try:\n                    y = await t\n                    drs_objects_with_signed_urls.append(y)\n\n                except Exception:\n                    signed_url = DrsObject(\n                                    self_uri=\"\",\n                                    id=\"\",\n                                    checksums=[],\n                                    size=0,\n                                    name=None,\n                                    errors=[f\"Exception in {err_function_msg} function\"],\n                                )\n\n                    drs_objects_with_signed_urls.append(signed_url)\n                    t.cancel()\n\n        return drs_objects_with_signed_urls\n\n    async def _run_download_parts(\n        self, drs_object: DrsObject, destination_path: Path, verbose: bool\n    ) -&gt; DrsObject:\n\"\"\"Determine number of parts for signed url and create tasks for each part, run them in batches.\n\n        Args:\n            drs_object: Information about a bucket object\n\n        Returns:\n            list of paths to files for each part, in order.\n        \"\"\"\n        # create a list of parts\n        parts = []\n        for start, size in self._parts_generator(\n            size=drs_object.size, part_size=self.part_size\n        ):\n            parts.append(\n                (\n                    start,\n                    size,\n                )\n            )\n\n        if len(parts) &gt; 1000:\n            if verbose:\n                logger.warning(f'Warning: tasks &gt; 1000 {drs_object.name} has over 1000 parts and is a large download. \\\n                ({len(parts)})')\n\n        if drs_object.size &gt; 20 * MB:\n            self.disable = False\n        else:\n            self.disable = True\n\n        paths = []\n        # TODO - tqdm ugly here?\n        for chunk_parts in tqdm.tqdm(\n            DrsAsyncManager.chunker(parts, self.max_simultaneous_part_handlers),\n            total=math.ceil(len(parts) / self.max_simultaneous_part_handlers),\n            desc=\"File Download Progress\",\n            file=sys.stdout,\n            leave=False,\n            disable=self.disable,\n        ):\n            chunk_tasks = []\n            existing_chunks = []\n            for start, size in chunk_parts:\n                # Check if part file exists and if so verify the expected size.\n                # If size matches the expected value then return the Path of the file_name for eventual reassembly.\n                # If size does not match then attempt to restart the download.\n                file_name = destination_path / f\"{drs_object.name}.{start}.{size}.part\"\n                file_path = Path(file_name)\n\n                if self.check_existing_parts(file_path, start, size, verbose):\n                    existing_chunks.append(file_path)\n                    continue\n\n                task = asyncio.create_task(\n                    self._drs_client.download_part(\n                        drs_object=drs_object,\n                        start=start,\n                        size=size,\n                        destination_path=destination_path,\n                        verbose=verbose\n                    )\n                )\n                chunk_tasks.append(task)\n\n            chunk_paths = await self.wait_till_completed(chunk_tasks, \"download_parts\")\n\n\"\"\"\n            Uncessesary logging message for the end user. When you take into account\n            that most downloads are going to take longer than 15 minutes and this message\n             will be spammed for every part that is already downlaoded when the resigning step happens.\n\n            if len(existing_chunks) &gt; 0:\n                #logger.info(f\"{drs_object.name} had {len(existing_chunks)} existing parts.\")\n            \"\"\"\n\n            chunk_paths.extend(existing_chunks)\n            # something bad happened\n            if None in chunk_paths:\n                if any(\n                    [\n                        \"RECOVERABLE in AIOHTTP\" in str(error)\n                        for error in drs_object.errors\n                    ]\n                ):\n                    return drs_object\n                else:\n                    if verbose:\n                        logger.error(f\"{drs_object.name} had missing part.\")\n                    return drs_object\n\n            paths.extend(chunk_paths)\n\n\"\"\"\n       print(\" LIST OF DRS OBJECT ERRORS AFTER DLOAD IN RUN DOWNLOAD PARTS\",drs_object.errors)\n       print(\"RECOVERABLE? \",any(['RECOVERABLE' in str(error) for error in drs_object.errors]))\n\n        if(any(['RECOVERABLE' in str(error) for error in drs_object.errors])):\n                return drs_object\n        \"\"\"\n\n        if (\n            None not in chunk_paths\n            and len(existing_chunks) == 0\n            and self.disable is True\n        ):\n            if verbose:\n                logger.info(\"%s Downloaded sucessfully\", drs_object.name)\n\n        drs_object.file_parts = paths\n\n        i = 1\n        filename = (\n            f\"{drs_object.name}\"\n            or drs_object.access_methods[0].access_url.split(\"/\")[-1].split(\"?\")[0]\n        )\n        original_file_name = Path(filename)\n        while True:\n            if os.path.isfile(destination_path.joinpath(filename)):\n                filename = f\"{original_file_name}({i})\"\n                i = i + 1\n                continue\n            break\n\n        # re-assemble and test the file parts\n        # hash function dynamic\n        checksum_type = drs_object.checksums[0].type\n        assert (\n            checksum_type in hashlib.algorithms_available\n        ), f\"Checksum {checksum_type} not supported.\"\n        checksum = hashlib.new(checksum_type)\n        with open(destination_path.joinpath(filename), \"wb\") as wfd:\n            # sort the items of the list in place - Numerically based on start i.e. \"xxxxxx.start.end.part\"\n            drs_object.file_parts.sort(key=lambda x: int(str(x).split(\".\")[-3]))\n\n            T_0 = time.time()\n            for f in tqdm.tqdm(\n                drs_object.file_parts,\n                total=len(drs_object.file_parts),\n                desc=f\"       {drs_object.name:50.50} stitching\",\n                file=sys.stdout,\n                leave=False,\n                disable=self.disable,\n            ):\n                fd = open(f, \"rb\")  # NOT ASYNC\n                wrapped_fd = Wrapped(fd, checksum)\n                # efficient way to write\n                await asyncio.to_thread(\n                    shutil.copyfileobj, wrapped_fd, wfd, 1024 * 1024 * 10\n                )\n                # explicitly close all\n                wrapped_fd.close()\n                f.unlink()\n                fd.close()\n                wfd.flush()\n            T_FIN = time.time()\n            if verbose:\n                logger.info(f\"TOTAL 'STITCHING' (md5 10*MB no flush) TIME {T_FIN-T_0} {original_file_name}\")\n        actual_checksum = checksum.hexdigest()\n\n        actual_size = os.stat(Path(destination_path.joinpath(filename))).st_size\n\n        # compare calculated md5 vs expected\n        expected_checksum = drs_object.checksums[0].checksum\n        if expected_checksum != actual_checksum:\n            msg = f\"Actual {checksum_type} hash {actual_checksum} does not match expected {expected_checksum}\"\n            if verbose:\n                logger.error(f\"Actual {checksum_type} hash {actual_checksum} \\\n                             does not match expected {expected_checksum}\")\n            drs_object.errors.append(msg)\n\n        if drs_object.size != actual_size:\n            msg = f\"The actual size {actual_size} does not match expected size {drs_object.size}\"\n            drs_object.errors.append(msg)\n\n        # parts will be purposefully saved if there is an error so that\n        # recovery script can have a chance to rebuild the file\n\n        return drs_object\n\n    async def _run_download(\n        self, drs_objects: List[DrsObject], destination_path: Path, verbose: bool\n    ) -&gt; List[DrsObject]:\n\"\"\"\n        Create tasks to sign and download, display progress.\n        Args:\n            drs_objects: list of drs objects to download\n\n        Returns:\n            updated list of drs objects\n        \"\"\"\n\n        # first sign the urls\n        tasks = []\n        for drs_object in drs_objects:\n            if len(drs_object.errors) == 0:\n                task = asyncio.create_task(self._drs_client.sign_url(drs_object=drs_object, verbose=verbose))\n                tasks.append(task)\n\n        drs_objects_with_signed_urls = await self.wait_till_completed(tasks, \"sign_url\")\n\n        tasks = []\n        for drs_object in drs_objects_with_signed_urls:\n            if len(drs_object.errors) == 0:\n                task = asyncio.create_task(\n                    self._run_download_parts(\n                        drs_object=drs_object, destination_path=destination_path, verbose=verbose\n                    )\n                )\n                tasks.append(task)\n\n            else:\n                logger.error(\n                    f\"{drs_object.id} has error {drs_object.errors}, not attempting anything further\"\n                )\n\n        drs_objects_with_file_parts = await self.wait_till_completed(tasks, \"run_download_parts\")\n\n        return drs_objects_with_file_parts\n\n    async def _run_get_objects(\n        self, object_ids: List[str], leave: bool, verbose: bool\n    ) -&gt; List[DrsObject]:\n\"\"\"Create async tasks to retrieve list DrsObject, displays progress.\n\n        Args:\n            object_ids: object_id from manifest\n            leave: leave flag to keep progress indicator displayed\n\n        Returns:\n\n        \"\"\"\n\n        tasks = []\n        for object_id in object_ids:\n            task = asyncio.create_task(self._drs_client.get_object(object_id=object_id, verbose=verbose))\n            tasks.append(task)\n\n        object_information = []\n\n        object_information = await self.wait_till_completed(tasks, \"get_object\")\n\n        return object_information\n\n    @classmethod\n    def chunker(cls, seq: Collection, size: int) -&gt; Iterator:\n\"\"\"Iterate over a list in chunks.\n\n        Args:\n            seq: an iterable\n            size: desired chunk size\n\n        Returns:\n            an iterator that returns lists of size or less\n        \"\"\"\n        return (seq[pos: pos + size] for pos in range(0, len(seq), size))\n\n    def get_objects(self, object_ids: List[str], verbose: bool) -&gt; List[DrsObject]:\n\"\"\"Create tasks for all object_ids, run them in batches, get information about the object.\n\n        Args:\n            object_ids: list of objects to fetch\n        \"\"\"\n\n        drs_objects = []\n\n        total_batches = math.ceil(\n            len(object_ids) / self.max_simultaneous_object_retrievers\n        )\n        # rounding\n        # this would imply that if batch count is 9.3, and you round down the last .3 is never\n        # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all\n\n        current = 0\n\n        for chunk_of_object_ids in DrsAsyncManager.chunker(\n            object_ids, self.max_simultaneous_object_retrievers\n        ):\n\n            drs_objects.extend(\n                asyncio.run(\n                    self._run_get_objects(\n                        object_ids=chunk_of_object_ids, leave=(current == total_batches), verbose=verbose\n                    )\n                )\n            )\n            current += 1\n\n        return drs_objects\n\n    def download(\n        self, drs_objects: List[DrsObject], destination_path: Path, duplicate: bool, verbose: bool\n    ) -&gt; List[DrsObject]:\n\"\"\"Split the drs_objects into manageable sizes, download the files.\n\n        Args:\n            drs_objects: list of DrsObject\n            destination_path: directory where to write files when complete\n\n        Returns:\n            DrsObjects updated with _file_parts\n        \"\"\"\n        while True:\n\n            filtered_objects = self.filter_existing_files(\n                drs_objects, destination_path, duplicate=duplicate, verbose=verbose\n            )\n            if len(filtered_objects) &lt; len(drs_objects):\n                complete_objects = [\n                    obj for obj in drs_objects if obj not in filtered_objects\n                ]\n                for obj in complete_objects:\n                    if verbose:\n                        logger.info(f\"{obj.name} already exists in {destination_path}. Skipping download.\")\n\n                if len(filtered_objects) == 0:\n                    logger.info(\n                        f\"All DRS objects already present in {destination_path}.\"\n                    )\n                    return\n\n            current = 0\n            updated_drs_objects = []\n\n            for chunk_of_drs_objects in DrsAsyncManager.chunker(\n                filtered_objects, self.max_simultaneous_object_retrievers\n            ):\n\n                completed_chunk = asyncio.run(\n                    self._run_download(\n                        drs_objects=chunk_of_drs_objects,\n                        destination_path=destination_path, verbose=verbose\n                    )\n                )\n                current += 1\n                updated_drs_objects.extend(completed_chunk)\n            if verbose:\n                logger.info(f\"UPDATED DRS OBJECTS \\n\\n {updated_drs_objects}\")\n\n            if \"RECOVERABLE in AIOHTTP\" not in str(updated_drs_objects):\n                break\n\n            else:\n                if verbose:\n                    logger.info(\"RECURSING \\n\\n\\n\")\n\n            for drsobject in drs_objects:\n                drsobject.errors.clear()\n\n        return updated_drs_objects\n\n    def optimize_workload(\n        self, verbose, drs_objects: List[DrsObject]\n    ) -&gt; List[DrsObject]:\n\"\"\"\n        Optimize the workload, sort prioritize and set thread management parameters.\n        Args:\n            drs_objects:\n\n        Returns:\n            same list that was passed\n        \"\"\"\n        # Now that we have the objects to download, we have an opportunity to shape the downloads\n        # e.g. are the smallest files first?  tweak MAX_* to optimize per workload\n        # TODO: If part sizes changed here, would this result in an error in test recovery?\n        # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case\n        # there is a pytest written for them that will fail otherwise\n\n        if len(drs_objects) == 1:\n            self.max_simultaneous_part_handlers = 50\n            self.part_size = 64 * MB\n            self.max_simultaneous_downloaders = 10\n            if verbose:\n                logger.info(\"part_size=%s\", self.part_size)\n\n        elif any(True for drs_object in drs_objects if (int(drs_object.size) &gt; GB)):\n            self.max_simultaneous_part_handlers = 3\n            self.part_size = 128 * MB\n            self.max_simultaneous_downloaders = 10\n            if verbose:\n                logger.info(\"part_size=%s\", self.part_size)\n\n        elif all((drs_object.size &lt; (5 * MB)) for drs_object in drs_objects):\n            self.part_size = 1 * MB\n            self.max_simultaneous_part_handlers = 2\n            self.max_simultaneous_downloaders = 10\n            if verbose:\n                logger.info(\"part_size=%s\", self.part_size)\n                logger.info(\"part_handlers=%s\", self.max_simultaneous_part_handlers)\n\n        else:\n            self.part_size = 128 * MB\n            self.max_simultaneous_part_handlers = 10\n            self.max_simultaneous_downloaders = 10\n            if verbose:\n                logger.info(\"part_size=%s\", self.part_size)\n                logger.info(\"part_handlers=%s\", self.max_simultaneous_part_handlers)\n\n        return drs_objects\n\n    def filter_existing_files(\n        self, drs_objects: List[DrsObject], destination_path: Path, duplicate: bool, verbose: bool\n    ) -&gt; List[DrsObject]:\n\"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory.\n\n        Args:\n            drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded)\n            destination_path (Path): Download destination that may contain partially downloaded files\n\n        Returns:\n            List[DrsObject]: The DRS objects that have yet to be downloaded\n        \"\"\"\n\n        if verbose:\n            logger.info(f\"VALUE OF duplicate {duplicate}\")\n        if duplicate is True:\n            return drs_objects\n\n        # Testing File filtering by size also\n\"\"\"\n        for drs in drs_objects:\n            logger.info(f\"drs.size: {drs.size}  != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\")\n            if(drs.size != os.path.getsize(drs.name)):\n                logger.warning(f\"{drs.name} is the wrong size,\n                consider running this command again with the --duplicate flag\n                 so that your current file with the same name is\n                  not overwritten by this one that is on the path to downloading\")\n        \"\"\"\n        filtered_objects = [\n            drs for drs in drs_objects if (drs.name not in os.listdir(destination_path))\n            #  or drs.size != os.path.getsize(drs.name) &lt;-- this is used for filtering out wrong sized stuff\n        ]\n        if verbose:\n            logger.info(f\"VALUE OF FILTERED OBJECTS {filtered_objects}\")\n\n        return filtered_objects\n\n    def check_existing_parts(self, file_path: Path, start: int, size: int, verbose: bool) -&gt; bool:\n\"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it\n           prompts a new download process for that part.\n\n        Args:\n            file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part)\n            start (int): Beginning byte of the file part (ex. 1048577)\n            size (int): Final byte of the file part (ex. 1244278)\n\n        Returns:\n            bool: True if the file part exists in the destination and has the expected file size, False otherwise\n        \"\"\"\n\n        if file_path.exists():\n            expected_size = size - start + 1\n            if verbose:\n                logger.info(f\"EXPTECTED PART SIZE SIZE {expected_size}\")\n\n            actual_size = file_path.stat().st_size\n            sizes_match = actual_size == expected_size\n            if verbose:\n                logger.info(f\"ACTUAL SIZE {actual_size}\")\n\n            if sizes_match is True:\n                # this logger message is really redundant when you are downloading large files.\n                # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now\n                # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\")\n                return True\n\n        return False\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.__init__","title":"<code>__init__(drs_client, show_progress=True, part_size=DEFAULT_PART_SIZE, max_simultaneous_object_retrievers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS, max_simultaneous_downloaders=DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS, max_simultaneous_part_handlers=DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS, max_simultaneous_object_signers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>drs_client</code> <code>DrsClient</code> <p>the client that will interact with server</p> required <code>show_progress</code> <code>bool</code> <p>show progress bars</p> <code>True</code> <code>part_size</code> <code>int</code> <p>tweak to optimize workload</p> <code>DEFAULT_PART_SIZE</code> <code>max_simultaneous_object_retrievers</code> <p>tweak to optimize workload</p> <code>DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS</code> <code>max_simultaneous_downloaders</code> <p>tweak to optimize workload</p> <code>DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS</code> <code>max_simultaneous_part_handlers</code> <p>tweak to optimize workload</p> <code>DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS</code> Source code in <code>drs_downloader/manager.py</code> <pre><code>def __init__(\n    self,\n    drs_client: DrsClient,\n    show_progress: bool = True,\n    part_size: int = DEFAULT_PART_SIZE,\n    max_simultaneous_object_retrievers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_RETRIEVERS,\n    max_simultaneous_downloaders=DEFAULT_MAX_SIMULTANEOUS_DOWNLOADERS,\n    max_simultaneous_part_handlers=DEFAULT_MAX_SIMULTANEOUS_PART_HANDLERS,\n    max_simultaneous_object_signers=DEFAULT_MAX_SIMULTANEOUS_OBJECT_SIGNERS,\n):\n\"\"\"\n\n    Args:\n        drs_client: the client that will interact with server\n        show_progress: show progress bars\n        part_size: tweak to optimize workload\n        max_simultaneous_object_retrievers: tweak to optimize workload\n        max_simultaneous_downloaders: tweak to optimize workload\n        max_simultaneous_part_handlers: tweak to optimize workload\n    \"\"\"\n    # \"\"\"Implements abstract constructor.\"\"\"\n    super().__init__(drs_client=drs_client)\n    self.max_simultaneous_object_retrievers = max_simultaneous_object_retrievers\n    self.max_simultaneous_object_signers = max_simultaneous_object_signers\n    self.max_simultaneous_downloaders = max_simultaneous_downloaders\n    self.max_simultaneous_part_handlers = max_simultaneous_part_handlers\n    self.disable = not show_progress\n    self.part_size = part_size\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.check_existing_parts","title":"<code>check_existing_parts(file_path, start, size, verbose)</code>","text":"<p>Checks if any file parts have already been downloaded. If a file part was partially downloaded then it    prompts a new download process for that part.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part)</p> required <code>start</code> <code>int</code> <p>Beginning byte of the file part (ex. 1048577)</p> required <code>size</code> <code>int</code> <p>Final byte of the file part (ex. 1244278)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file part exists in the destination and has the expected file size, False otherwise</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>def check_existing_parts(self, file_path: Path, start: int, size: int, verbose: bool) -&gt; bool:\n\"\"\"Checks if any file parts have already been downloaded. If a file part was partially downloaded then it\n       prompts a new download process for that part.\n\n    Args:\n        file_path (Path): Path of the given file part (ex. HG00536.final.cram.crai.1048577.1244278.part)\n        start (int): Beginning byte of the file part (ex. 1048577)\n        size (int): Final byte of the file part (ex. 1244278)\n\n    Returns:\n        bool: True if the file part exists in the destination and has the expected file size, False otherwise\n    \"\"\"\n\n    if file_path.exists():\n        expected_size = size - start + 1\n        if verbose:\n            logger.info(f\"EXPTECTED PART SIZE SIZE {expected_size}\")\n\n        actual_size = file_path.stat().st_size\n        sizes_match = actual_size == expected_size\n        if verbose:\n            logger.info(f\"ACTUAL SIZE {actual_size}\")\n\n        if sizes_match is True:\n            # this logger message is really redundant when you are downloading large files.\n            # For the purposes of cleaning up the UI on expired signed URLS going to comment this out for now\n            # logger.info(f\"{file_path.name} exists and has expected size. Skipping download.\")\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.chunker","title":"<code>chunker(seq, size)</code>  <code>classmethod</code>","text":"<p>Iterate over a list in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>Collection</code> <p>an iterable</p> required <code>size</code> <code>int</code> <p>desired chunk size</p> required <p>Returns:</p> Type Description <code>Iterator</code> <p>an iterator that returns lists of size or less</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>@classmethod\ndef chunker(cls, seq: Collection, size: int) -&gt; Iterator:\n\"\"\"Iterate over a list in chunks.\n\n    Args:\n        seq: an iterable\n        size: desired chunk size\n\n    Returns:\n        an iterator that returns lists of size or less\n    \"\"\"\n    return (seq[pos: pos + size] for pos in range(0, len(seq), size))\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.download","title":"<code>download(drs_objects, destination_path, duplicate, verbose)</code>","text":"<p>Split the drs_objects into manageable sizes, download the files.</p> <p>Parameters:</p> Name Type Description Default <code>drs_objects</code> <code>List[DrsObject]</code> <p>list of DrsObject</p> required <code>destination_path</code> <code>Path</code> <p>directory where to write files when complete</p> required <p>Returns:</p> Type Description <code>List[DrsObject]</code> <p>DrsObjects updated with _file_parts</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>def download(\n    self, drs_objects: List[DrsObject], destination_path: Path, duplicate: bool, verbose: bool\n) -&gt; List[DrsObject]:\n\"\"\"Split the drs_objects into manageable sizes, download the files.\n\n    Args:\n        drs_objects: list of DrsObject\n        destination_path: directory where to write files when complete\n\n    Returns:\n        DrsObjects updated with _file_parts\n    \"\"\"\n    while True:\n\n        filtered_objects = self.filter_existing_files(\n            drs_objects, destination_path, duplicate=duplicate, verbose=verbose\n        )\n        if len(filtered_objects) &lt; len(drs_objects):\n            complete_objects = [\n                obj for obj in drs_objects if obj not in filtered_objects\n            ]\n            for obj in complete_objects:\n                if verbose:\n                    logger.info(f\"{obj.name} already exists in {destination_path}. Skipping download.\")\n\n            if len(filtered_objects) == 0:\n                logger.info(\n                    f\"All DRS objects already present in {destination_path}.\"\n                )\n                return\n\n        current = 0\n        updated_drs_objects = []\n\n        for chunk_of_drs_objects in DrsAsyncManager.chunker(\n            filtered_objects, self.max_simultaneous_object_retrievers\n        ):\n\n            completed_chunk = asyncio.run(\n                self._run_download(\n                    drs_objects=chunk_of_drs_objects,\n                    destination_path=destination_path, verbose=verbose\n                )\n            )\n            current += 1\n            updated_drs_objects.extend(completed_chunk)\n        if verbose:\n            logger.info(f\"UPDATED DRS OBJECTS \\n\\n {updated_drs_objects}\")\n\n        if \"RECOVERABLE in AIOHTTP\" not in str(updated_drs_objects):\n            break\n\n        else:\n            if verbose:\n                logger.info(\"RECURSING \\n\\n\\n\")\n\n        for drsobject in drs_objects:\n            drsobject.errors.clear()\n\n    return updated_drs_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.filter_existing_files","title":"<code>filter_existing_files(drs_objects, destination_path, duplicate, verbose)</code>","text":"<p>Remove any DRS objects from a given list if they are already exist in the destination directory.</p> <p>Parameters:</p> Name Type Description Default <code>drs_objects</code> <code>List[DrsObject]</code> <p>The DRS objects from the manifest (some may already be downloaded)</p> required <code>destination_path</code> <code>Path</code> <p>Download destination that may contain partially downloaded files</p> required <p>Returns:</p> Type Description <code>List[DrsObject]</code> <p>List[DrsObject]: The DRS objects that have yet to be downloaded</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>def filter_existing_files(\n    self, drs_objects: List[DrsObject], destination_path: Path, duplicate: bool, verbose: bool\n) -&gt; List[DrsObject]:\n\"\"\"Remove any DRS objects from a given list if they are already exist in the destination directory.\n\n    Args:\n        drs_objects (List[DrsObject]): The DRS objects from the manifest (some may already be downloaded)\n        destination_path (Path): Download destination that may contain partially downloaded files\n\n    Returns:\n        List[DrsObject]: The DRS objects that have yet to be downloaded\n    \"\"\"\n\n    if verbose:\n        logger.info(f\"VALUE OF duplicate {duplicate}\")\n    if duplicate is True:\n        return drs_objects\n\n    # Testing File filtering by size also\n\"\"\"\n    for drs in drs_objects:\n        logger.info(f\"drs.size: {drs.size}  != os.path.getsize(drs.name) {os.path.getsize(drs.name)}\")\n        if(drs.size != os.path.getsize(drs.name)):\n            logger.warning(f\"{drs.name} is the wrong size,\n            consider running this command again with the --duplicate flag\n             so that your current file with the same name is\n              not overwritten by this one that is on the path to downloading\")\n    \"\"\"\n    filtered_objects = [\n        drs for drs in drs_objects if (drs.name not in os.listdir(destination_path))\n        #  or drs.size != os.path.getsize(drs.name) &lt;-- this is used for filtering out wrong sized stuff\n    ]\n    if verbose:\n        logger.info(f\"VALUE OF FILTERED OBJECTS {filtered_objects}\")\n\n    return filtered_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.get_objects","title":"<code>get_objects(object_ids, verbose)</code>","text":"<p>Create tasks for all object_ids, run them in batches, get information about the object.</p> <p>Parameters:</p> Name Type Description Default <code>object_ids</code> <code>List[str]</code> <p>list of objects to fetch</p> required Source code in <code>drs_downloader/manager.py</code> <pre><code>def get_objects(self, object_ids: List[str], verbose: bool) -&gt; List[DrsObject]:\n\"\"\"Create tasks for all object_ids, run them in batches, get information about the object.\n\n    Args:\n        object_ids: list of objects to fetch\n    \"\"\"\n\n    drs_objects = []\n\n    total_batches = math.ceil(\n        len(object_ids) / self.max_simultaneous_object_retrievers\n    )\n    # rounding\n    # this would imply that if batch count is 9.3, and you round down the last .3 is never\n    # actually downloaded since there are only 9 batches. math.ciel would round up if there is a decimal at all\n\n    current = 0\n\n    for chunk_of_object_ids in DrsAsyncManager.chunker(\n        object_ids, self.max_simultaneous_object_retrievers\n    ):\n\n        drs_objects.extend(\n            asyncio.run(\n                self._run_get_objects(\n                    object_ids=chunk_of_object_ids, leave=(current == total_batches), verbose=verbose\n                )\n            )\n        )\n        current += 1\n\n    return drs_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsAsyncManager.optimize_workload","title":"<code>optimize_workload(verbose, drs_objects)</code>","text":"<p>Optimize the workload, sort prioritize and set thread management parameters. Args:     drs_objects:</p> <p>Returns:</p> Type Description <code>List[DrsObject]</code> <p>same list that was passed</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>def optimize_workload(\n    self, verbose, drs_objects: List[DrsObject]\n) -&gt; List[DrsObject]:\n\"\"\"\n    Optimize the workload, sort prioritize and set thread management parameters.\n    Args:\n        drs_objects:\n\n    Returns:\n        same list that was passed\n    \"\"\"\n    # Now that we have the objects to download, we have an opportunity to shape the downloads\n    # e.g. are the smallest files first?  tweak MAX_* to optimize per workload\n    # TODO: If part sizes changed here, would this result in an error in test recovery?\n    # Going to maek all part sizes 128MB to solve the problem above except for the small files because in that case\n    # there is a pytest written for them that will fail otherwise\n\n    if len(drs_objects) == 1:\n        self.max_simultaneous_part_handlers = 50\n        self.part_size = 64 * MB\n        self.max_simultaneous_downloaders = 10\n        if verbose:\n            logger.info(\"part_size=%s\", self.part_size)\n\n    elif any(True for drs_object in drs_objects if (int(drs_object.size) &gt; GB)):\n        self.max_simultaneous_part_handlers = 3\n        self.part_size = 128 * MB\n        self.max_simultaneous_downloaders = 10\n        if verbose:\n            logger.info(\"part_size=%s\", self.part_size)\n\n    elif all((drs_object.size &lt; (5 * MB)) for drs_object in drs_objects):\n        self.part_size = 1 * MB\n        self.max_simultaneous_part_handlers = 2\n        self.max_simultaneous_downloaders = 10\n        if verbose:\n            logger.info(\"part_size=%s\", self.part_size)\n            logger.info(\"part_handlers=%s\", self.max_simultaneous_part_handlers)\n\n    else:\n        self.part_size = 128 * MB\n        self.max_simultaneous_part_handlers = 10\n        self.max_simultaneous_downloaders = 10\n        if verbose:\n            logger.info(\"part_size=%s\", self.part_size)\n            logger.info(\"part_handlers=%s\", self.max_simultaneous_part_handlers)\n\n    return drs_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager","title":"<code>DrsManager</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Manage DRSClient workload.</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>class DrsManager(ABC):\n\"\"\"Manage DRSClient workload.\"\"\"\n\n    @abstractmethod\n    def __init__(self, drs_client: DrsClient):\n        self._drs_client = drs_client\n\n    @abstractmethod\n    def get_objects(self, object_ids: List[str]) -&gt; List[DrsObject]:\n\"\"\"Fetch list of DRSObject from passed ids.\n\n        Args:\n            object_ids: list of objects to fetch\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def download(\n        self, drs_objects: List[DrsObject], destination_path: Path\n    ) -&gt; List[DrsObject]:\n\"\"\"Split the drs_objects into manageable parts, download the files.\n\n        Args:\n            drs_objects: objects to download\n            destination_path: directory where to write files when complete\n\n        Returns:\n            list of updated DrsObjects\n        \"\"\"\n\n    @abstractmethod\n    async def optimize_workload(self, drs_objects: List[DrsObject]) -&gt; List[DrsObject]:\n\"\"\"\n        Optimize the workload, sort prioritize and set thread management parameters.\n        Args:\n            drs_objects:\n\n        Returns:\n\n        \"\"\"\n        # TODO - now that we have the objects to download, we have an opportunity to shape the downloads\n        # TODO - e.g. smallest files first?  tweak MAX_* to optimize per workload\n        return drs_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.download","title":"<code>download(drs_objects, destination_path)</code>  <code>abstractmethod</code>","text":"<p>Split the drs_objects into manageable parts, download the files.</p> <p>Parameters:</p> Name Type Description Default <code>drs_objects</code> <code>List[DrsObject]</code> <p>objects to download</p> required <code>destination_path</code> <code>Path</code> <p>directory where to write files when complete</p> required <p>Returns:</p> Type Description <code>List[DrsObject]</code> <p>list of updated DrsObjects</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>@abstractmethod\ndef download(\n    self, drs_objects: List[DrsObject], destination_path: Path\n) -&gt; List[DrsObject]:\n\"\"\"Split the drs_objects into manageable parts, download the files.\n\n    Args:\n        drs_objects: objects to download\n        destination_path: directory where to write files when complete\n\n    Returns:\n        list of updated DrsObjects\n    \"\"\"\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.get_objects","title":"<code>get_objects(object_ids)</code>  <code>abstractmethod</code>","text":"<p>Fetch list of DRSObject from passed ids.</p> <p>Parameters:</p> Name Type Description Default <code>object_ids</code> <code>List[str]</code> <p>list of objects to fetch</p> required Source code in <code>drs_downloader/manager.py</code> <pre><code>@abstractmethod\ndef get_objects(self, object_ids: List[str]) -&gt; List[DrsObject]:\n\"\"\"Fetch list of DRSObject from passed ids.\n\n    Args:\n        object_ids: list of objects to fetch\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.DrsManager.optimize_workload","title":"<code>optimize_workload(drs_objects)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Optimize the workload, sort prioritize and set thread management parameters. Args:     drs_objects:</p> <p>Returns:</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>@abstractmethod\nasync def optimize_workload(self, drs_objects: List[DrsObject]) -&gt; List[DrsObject]:\n\"\"\"\n    Optimize the workload, sort prioritize and set thread management parameters.\n    Args:\n        drs_objects:\n\n    Returns:\n\n    \"\"\"\n    # TODO - now that we have the objects to download, we have an opportunity to shape the downloads\n    # TODO - e.g. smallest files first?  tweak MAX_* to optimize per workload\n    return drs_objects\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.Wrapped","title":"<code>Wrapped</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>drs_downloader/manager.py</code> <pre><code>class Wrapped(object):\n    def __init__(self, file, hash_method):\n\"\"\"\n        Wrap the read() method and calculate hash\n        Args:\n            file: destination file\n            hash_method: instantiated hash_method\n        \"\"\"\n        self._file = file\n        self._hash_method = hash_method\n\n    def read(self, size):\n        buffer = self._file.read(size)\n        self._hash_method.update(buffer)\n        return buffer\n\n    def __getattr__(self, attr):\n        return getattr(self._file, attr)\n</code></pre>"},{"location":"reference/manager.html#drs_downloader.manager.Wrapped.__init__","title":"<code>__init__(file, hash_method)</code>","text":"<p>Wrap the read() method and calculate hash Args:     file: destination file     hash_method: instantiated hash_method</p> Source code in <code>drs_downloader/manager.py</code> <pre><code>def __init__(self, file, hash_method):\n\"\"\"\n    Wrap the read() method and calculate hash\n    Args:\n        file: destination file\n        hash_method: instantiated hash_method\n    \"\"\"\n    self._file = file\n    self._hash_method = hash_method\n</code></pre>"},{"location":"reference/models.html","title":"models","text":""},{"location":"reference/models.html#drs_downloader.models.AccessMethod","title":"<code>AccessMethod</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@dataclass\nclass AccessMethod(object):\n\"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessmethod\"\"\"\n\n    access_url: str\n\"\"\"An AccessURL that can be used to fetch the actual object bytes.\"\"\"\n    type: str\n\"\"\"Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file)\"\"\"\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.AccessMethod.access_url","title":"<code>access_url: str</code>  <code>instance-attribute</code>","text":"<p>An AccessURL that can be used to fetch the actual object bytes.</p>"},{"location":"reference/models.html#drs_downloader.models.AccessMethod.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":"<p>Type of the access method. enum (s3, gs, ftp, gsiftp, globus, htsget, https, file)</p>"},{"location":"reference/models.html#drs_downloader.models.AccessURL","title":"<code>AccessURL</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@dataclass\nclass AccessURL(object):\n\"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_accessurl\"\"\"\n\n    headers: Dict[str, str]\n\"\"\"An optional list of headers to include in the HTTP request to url.\"\"\"\n    url: str\n\"\"\"A fully resolvable URL that can be used to fetch the actual object bytes.\"\"\"\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.AccessURL.headers","title":"<code>headers: Dict[str, str]</code>  <code>instance-attribute</code>","text":"<p>An optional list of headers to include in the HTTP request to url.</p>"},{"location":"reference/models.html#drs_downloader.models.AccessURL.url","title":"<code>url: str</code>  <code>instance-attribute</code>","text":"<p>A fully resolvable URL that can be used to fetch the actual object bytes.</p>"},{"location":"reference/models.html#drs_downloader.models.Checksum","title":"<code>Checksum</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@dataclass\nclass Checksum(object):\n\"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_checksum\"\"\"\n\n    checksum: str\n\"\"\"The hex-string encoded checksum for the data.\"\"\"\n    type: str\n\"\"\"The digest method used to create the checksum.\"\"\"\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.Checksum.checksum","title":"<code>checksum: str</code>  <code>instance-attribute</code>","text":"<p>The hex-string encoded checksum for the data.</p>"},{"location":"reference/models.html#drs_downloader.models.Checksum.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":"<p>The digest method used to create the checksum.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsClient","title":"<code>DrsClient</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Interact with DRS service.</p> Source code in <code>drs_downloader/models.py</code> <pre><code>class DrsClient(ABC):\n\"\"\"Interact with DRS service.\"\"\"\n\n    def __init__(self, statistics: Statistics = Statistics()):\n        self.statistics = statistics\n\n    @abstractmethod\n    async def download_part(\n        self, drs_object: DrsObject, start: int, size: int, destination_path: Path, verbose: bool = False\n    ) -&gt; Optional[Path]:\n\n\"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None\n\n        Args:\n            destination_path: where to save the part\n            drs_object: state of download\n            start: segment start\n            size: segment end\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def sign_url(self, drs_object: DrsObject) -&gt; DrsObject:\n\"\"\"Retrieve signed url from service return populated DrsObject AccessMethod\n\n        Args:\n            drs_object:\n\n        Returns:\n            populated DrsObject\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_object(self, object_id: str) -&gt; DrsObject:\n\"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.DrsClient.download_part","title":"<code>download_part(drs_object, start, size, destination_path, verbose=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Download and save part of a file to disk; on error, update drs_object.errors return None</p> <p>Parameters:</p> Name Type Description Default <code>destination_path</code> <code>Path</code> <p>where to save the part</p> required <code>drs_object</code> <code>DrsObject</code> <p>state of download</p> required <code>start</code> <code>int</code> <p>segment start</p> required <code>size</code> <code>int</code> <p>segment end</p> required Source code in <code>drs_downloader/models.py</code> <pre><code>@abstractmethod\nasync def download_part(\n    self, drs_object: DrsObject, start: int, size: int, destination_path: Path, verbose: bool = False\n) -&gt; Optional[Path]:\n\n\"\"\"Download and save part of a file to disk; on error, update drs_object.errors return None\n\n    Args:\n        destination_path: where to save the part\n        drs_object: state of download\n        start: segment start\n        size: segment end\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.DrsClient.get_object","title":"<code>get_object(object_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieve size, checksums, etc. populate DrsObject.</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@abstractmethod\nasync def get_object(self, object_id: str) -&gt; DrsObject:\n\"\"\"Retrieve size, checksums, etc. populate DrsObject.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.DrsClient.sign_url","title":"<code>sign_url(drs_object)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieve signed url from service return populated DrsObject AccessMethod</p> <p>Parameters:</p> Name Type Description Default <code>drs_object</code> <code>DrsObject</code> required <p>Returns:</p> Type Description <code>DrsObject</code> <p>populated DrsObject</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@abstractmethod\nasync def sign_url(self, drs_object: DrsObject) -&gt; DrsObject:\n\"\"\"Retrieve signed url from service return populated DrsObject AccessMethod\n\n    Args:\n        drs_object:\n\n    Returns:\n        populated DrsObject\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.DrsObject","title":"<code>DrsObject</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@dataclass\nclass DrsObject(object):\n\"\"\"See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_drsobject\"\"\"\n\n    id: str\n\"\"\"An identifier unique to this DrsObject.\"\"\"\n    self_uri: str\n\"\"\"A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object.\"\"\"\n    checksums: List[Checksum]\n\"\"\"Needed for integrity check.\"\"\"\n    size: int\n\"\"\"Needed for multi part download.\"\"\"\n    name: str\n\"\"\"A string that can be used to name a DrsObject.\"\"\"\n    file_parts: List[Path] = field(default_factory=list)\n\"\"\"List of file parts in order of assembly.\"\"\"\n    errors: List[str] = field(default_factory=list)\n\"\"\"List of errors.\"\"\"\n    access_methods: List[AccessMethod] = field(default_factory=list)\n\"\"\"Signed url.\"\"\"\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.access_methods","title":"<code>access_methods: List[AccessMethod] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Signed url.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.checksums","title":"<code>checksums: List[Checksum]</code>  <code>instance-attribute</code>","text":"<p>Needed for integrity check.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.errors","title":"<code>errors: List[str] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of errors.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.file_parts","title":"<code>file_parts: List[Path] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of file parts in order of assembly.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>An identifier unique to this DrsObject.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>A string that can be used to name a DrsObject.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.self_uri","title":"<code>self_uri: str</code>  <code>instance-attribute</code>","text":"<p>A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object.</p>"},{"location":"reference/models.html#drs_downloader.models.DrsObject.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":"<p>Needed for multi part download.</p>"},{"location":"reference/models.html#drs_downloader.models.Statistics","title":"<code>Statistics</code>  <code>dataclass</code>","text":"<p>This is where we can share data between threads</p> Source code in <code>drs_downloader/models.py</code> <pre><code>@dataclass\nclass Statistics:\n\"\"\"This is where we can share data between threads\"\"\"\n\n    lock: threading.Lock = threading.Lock()\n    max_files_open: int = 0\n    pid: object = os.getpid()\n\n    def set_max_files_open(self):\n\"\"\"Threadsafe way to determine current number of open files.\n\n        Note: only tested on Mac\n        \"\"\"\n        self.lock.acquire()\n        system = platform.system()\n        if system == \"Darwin\":\n            open_fd = len(set(os.listdir(\"/dev/fd/\")))\n        elif system == \"Windows\":\n            # TODO install psutils - len(Process.open_files())\n            open_fd = 0\n        else:\n            open_fd = len(set(os.listdir(f\"/proc/{self.pid}/fd/\")))\n        if open_fd &gt; self.max_files_open:\n            self.max_files_open = open_fd\n        self.lock.release()\n</code></pre>"},{"location":"reference/models.html#drs_downloader.models.Statistics.set_max_files_open","title":"<code>set_max_files_open()</code>","text":"<p>Threadsafe way to determine current number of open files.</p> <p>Note: only tested on Mac</p> Source code in <code>drs_downloader/models.py</code> <pre><code>def set_max_files_open(self):\n\"\"\"Threadsafe way to determine current number of open files.\n\n    Note: only tested on Mac\n    \"\"\"\n    self.lock.acquire()\n    system = platform.system()\n    if system == \"Darwin\":\n        open_fd = len(set(os.listdir(\"/dev/fd/\")))\n    elif system == \"Windows\":\n        # TODO install psutils - len(Process.open_files())\n        open_fd = 0\n    else:\n        open_fd = len(set(os.listdir(f\"/proc/{self.pid}/fd/\")))\n    if open_fd &gt; self.max_files_open:\n        self.max_files_open = open_fd\n    self.lock.release()\n</code></pre>"},{"location":"reference/upgrader.html","title":"upgrader","text":""},{"location":"reference/upgrader.html#drs_downloader.upgrader.Upgrader","title":"<code>Upgrader</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>drs_downloader/upgrader.py</code> <pre><code>class Upgrader(ABC):\n    def __init__(self):\n        release_path = \"anvilproject/drs_downloader/releases/latest\"\n        self.release_url = f\"https://github.com/{release_path}\"\n        self.api_url = f\"https://api.github.com/repos/{release_path}\"\n\n    def upgrade(self, dest: str = os.getcwd(), force=False) -&gt; Path:\n\"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/\n\n        Args:\n            dest (str, optional): download destination. Defaults to os.getcwd().\n            force (bool, optional): forces upgrade even if version is up to date. Defaults to False.\n\n        Raises:\n            Exception: If the operating system can not be reliably determined\n            Exception: If the checksum for the new executable does not match the expected value\n\n        Returns:\n            Path: The downloaded executable.\n        \"\"\"\n\n        # Perform upgrade only if the program is being run as an executable and not as a script\n        if getattr(sys, \"frozen\", False) and hasattr(sys, \"_MEIPASS\"):\n            logger.info(\"running in a PyInstaller bundle\")\n        else:\n            logger.info(\"Running from a script\")\n\n        # Upgrade if newer version is available\n        json = requests.get(self.api_url).json()\n        new_version = version.parse(json[\"tag_name\"])\n        current_version = version.parse(__version__)\n\n        if current_version &gt;= new_version:\n            logger.info(\"Latest version already installed\")\n            if force is False:\n                return\n\n        # Determine download url for operating system\n        system = platform.system()\n        if system == \"Darwin\":\n            exe = \"drs-downloader-macOS\"\n        elif system == \"Linux\":\n            exe = \"drs-downloader-Linux\"\n        elif system == \"Windows\":\n            exe = \"drs-downloader-Windows.exe\"\n        else:\n            raise Exception(\n                f\"Unknown operating system detected. See the release page for manual upgrade: {self.release_url}\"\n            )\n\n        download_url = f\"{self.release_url}/download/{exe}\"\n        checksum_url = f\"{self.release_url}/download/checksums.txt\"\n\n        # Download executable and checksum files to temporary directory for checksum verification\n        verified_exe = None\n\n        # We use a temporary directory here to prevent files that might not pass the\n        # checksum step from remaining in the user's filesystem.\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            unverified_exe = self._download_file(download_url, tmp_dir)\n            checksum_path = self._download_file(checksum_url, tmp_dir)\n\n            checksums_match = self._verify_checksums(unverified_exe, checksum_path)\n            if checksums_match is False:\n                raise Exception(\"Actual hash does not match expected hash\")\n\n            # Backup old executable\n            self._backup(Path(dest, exe))\n\n            # If checksum is verified move new executable to current directory\n            verified_exe = shutil.move(unverified_exe, dest)\n\n        return Path(verified_exe)\n\n    def _backup(self, old_exe: Path):\n\"\"\"Backups the executable if it is already present in the destination directory.\n\n        Example:\n            Download destination is /Users/liam and /Users/liam/drs_downloader-macOS already\n            exists so it will be moved to /Users/liam/drs-downloader-macOS.bak/drs-downloader-macOS.\n\n        Args:\n            dest (str): download destination\n        \"\"\"\n\n        if old_exe.is_file() is False:\n            return\n\n        backup_dir = Path(old_exe.parent, f\"{old_exe.name}.bak\")\n        backup_dir.mkdir(parents=True, exist_ok=True)\n\n        shutil.move(old_exe, backup_dir)\n\n    def _download_file(self, url: str, dest: str) -&gt; Path:\n\"\"\"Downloads a file given an URL.\n\n        Example:\n            url is https://example.com/foo.zip and dest is /Users/liam so foo\n            will be downloaded to /Users/liam/foo.zip\n\n        Args:\n            url (str): URL to request the file from\n            dest (str): download destination\n\n        Returns:\n            Path: path of the downloaded file\n        \"\"\"\n\n        response = requests.get(url)\n        file_name = url.split(\"/\")[-1]\n        path = Path(dest, file_name)\n        with open(path, \"wb\") as f:\n            f.write(response.content)\n\n        return path\n\n    def _verify_checksums(self, file: str, checksums: str) -&gt; bool:\n\"\"\"Compares checksums for a given file against those in a given list (typically checksums.txt)\n\n        Args:\n            file (str): File to verify checksums for\n            checksums (str): File containing checksums\n\n        Returns:\n            bool: True if the expected and actual checksums match, False otherwise\n        \"\"\"\n\n        expected_sha = \"\"\n        with open(checksums, \"r\") as checksum_file:\n            lines = checksum_file.readlines()\n            for line in lines:\n                # If filename is found then use that checksum as the expected value\n                if file.stem in line:\n                    expected_sha = line.split()[0]\n\n        # Verify checksums\n        sha_hash = hashlib.sha256()\n        sha_hash.update(open(file, \"rb\").read())\n        actual_sha = sha_hash.hexdigest()\n\n        return expected_sha == actual_sha\n</code></pre>"},{"location":"reference/upgrader.html#drs_downloader.upgrader.Upgrader.upgrade","title":"<code>upgrade(dest=os.getcwd(), force=False)</code>","text":"<p>Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>download destination. Defaults to os.getcwd().</p> <code>getcwd()</code> <code>force</code> <code>bool</code> <p>forces upgrade even if version is up to date. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the operating system can not be reliably determined</p> <code>Exception</code> <p>If the checksum for the new executable does not match the expected value</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The downloaded executable.</p> Source code in <code>drs_downloader/upgrader.py</code> <pre><code>def upgrade(self, dest: str = os.getcwd(), force=False) -&gt; Path:\n\"\"\"Upgrades the drs_downloader executable and backups the old version to drs_downloader.bak/\n\n    Args:\n        dest (str, optional): download destination. Defaults to os.getcwd().\n        force (bool, optional): forces upgrade even if version is up to date. Defaults to False.\n\n    Raises:\n        Exception: If the operating system can not be reliably determined\n        Exception: If the checksum for the new executable does not match the expected value\n\n    Returns:\n        Path: The downloaded executable.\n    \"\"\"\n\n    # Perform upgrade only if the program is being run as an executable and not as a script\n    if getattr(sys, \"frozen\", False) and hasattr(sys, \"_MEIPASS\"):\n        logger.info(\"running in a PyInstaller bundle\")\n    else:\n        logger.info(\"Running from a script\")\n\n    # Upgrade if newer version is available\n    json = requests.get(self.api_url).json()\n    new_version = version.parse(json[\"tag_name\"])\n    current_version = version.parse(__version__)\n\n    if current_version &gt;= new_version:\n        logger.info(\"Latest version already installed\")\n        if force is False:\n            return\n\n    # Determine download url for operating system\n    system = platform.system()\n    if system == \"Darwin\":\n        exe = \"drs-downloader-macOS\"\n    elif system == \"Linux\":\n        exe = \"drs-downloader-Linux\"\n    elif system == \"Windows\":\n        exe = \"drs-downloader-Windows.exe\"\n    else:\n        raise Exception(\n            f\"Unknown operating system detected. See the release page for manual upgrade: {self.release_url}\"\n        )\n\n    download_url = f\"{self.release_url}/download/{exe}\"\n    checksum_url = f\"{self.release_url}/download/checksums.txt\"\n\n    # Download executable and checksum files to temporary directory for checksum verification\n    verified_exe = None\n\n    # We use a temporary directory here to prevent files that might not pass the\n    # checksum step from remaining in the user's filesystem.\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        unverified_exe = self._download_file(download_url, tmp_dir)\n        checksum_path = self._download_file(checksum_url, tmp_dir)\n\n        checksums_match = self._verify_checksums(unverified_exe, checksum_path)\n        if checksums_match is False:\n            raise Exception(\"Actual hash does not match expected hash\")\n\n        # Backup old executable\n        self._backup(Path(dest, exe))\n\n        # If checksum is verified move new executable to current directory\n        verified_exe = shutil.move(unverified_exe, dest)\n\n    return Path(verified_exe)\n</code></pre>"},{"location":"reference/clients/index.html","title":"clients","text":"<p>Download clients that will be used by the manager module to perform the following:</p> <ul> <li>authentication requests</li> <li>URL signing</li> <li>part download and reassembly</li> </ul>"},{"location":"reference/clients/gen3.html","title":"gen3","text":""},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient","title":"<code>Gen3DrsClient</code>","text":"<p>             Bases: <code>DrsClient</code></p> <p>Calls the Gen3 DRS server indexd</p> Source code in <code>drs_downloader/clients/gen3.py</code> <pre><code>class Gen3DrsClient(DrsClient):\n\"\"\"\n    Calls the Gen3 DRS server indexd\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key_path,\n        endpoint,\n        access_token_resource_path=\"/user/credentials/cdis/access_token\",\n        drs_api=\"/ga4gh/drs/v1/objects/\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.authorized = None\n        self.api_key = None\n        self.endpoint = endpoint\n        self.token = None\n        self.access_token_resource_path = access_token_resource_path\n        self.api_key_path = api_key_path\n        self.drs_api = drs_api\n\n    async def authorize(self):\n        full_key_path = os.path.expanduser(self.api_key_path)\n        try:\n            with open(full_key_path) as f:\n                self.api_key = json.load(f)\n            code = await self.update_access_token()\n            if code == 401:\n                logger.error(\"Invalid access token in {}\".format(full_key_path))\n                self.api_key = None\n            elif code != 200:\n                logger.error(\n                    \"Error {} getting Access token for {}\".format(code, self.endpoint)\n                )\n                logger.error(\"Using {}\".format(full_key_path))\n                self.api_key = None\n        except Exception as e:\n            self.api_key = None\n            raise e\n\n    # Obtain an access_token using the provided Fence API key.\n    # The client object will retain the access key for subsequent calls\n    async def update_access_token(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        api_url = \"{0}{1}\".format(self.endpoint, self.access_token_resource_path)\n        async with aiohttp.ClientSession(headers=headers) as session:\n            response = await session.post(api_url, headers=headers, json=self.api_key)\n            if response.status == 200:\n                resp = await response.json()\n                self.token = resp[\"access_token\"]\n                self.authorized = True\n            else:\n                self.authorized = False\n        return response.status\n\n    async def download_part(\n        self, drs_object: DrsObject, start: int, size: int, destination_path: Path\n    ) -&gt; Optional[Path]:\n        try:\n\n            if not self.authorized:\n                await self.authorize()\n\n            headers = {\"Range\": f\"bytes={start}-{size}\"}\n\n            file_name = destination_path / f\"{drs_object.name}.{start}.{size}.part\"\n            Path(file_name).parent.mkdir(parents=True, exist_ok=True)\n\n            async with aiohttp.ClientSession(headers=headers) as session:\n                async with session.get(\n                    drs_object.access_methods[0].access_url\n                ) as request:\n                    file = await aiofiles.open(file_name, \"wb\")\n                    self.statistics.set_max_files_open()\n                    async for data in request.content.iter_any():  # uses less memory\n                        await file.write(data)\n                    await file.close()\n                    return Path(file_name)\n        except Exception as e:\n            logger.error(f\"gen3.download_part {str(e)}\")\n            drs_object.errors.append(str(e))\n            return None\n\n    async def sign_url(self, drs_object: DrsObject) -&gt; DrsObject:\n\"\"\"Call fence's /user/data/download/ endpoint.\"\"\"\n\n        headers = {\n            \"authorization\": \"Bearer \" + self.token,\n            \"content-type\": \"application/json\",\n        }\n        async with aiohttp.ClientSession(headers=headers) as session:\n            async with session.get(\n                url=f\"{self.endpoint}/user/data/download/{drs_object.id.split(':')[-1]}\"\n            ) as response:\n                try:\n                    self.statistics.set_max_files_open()\n                    response.raise_for_status()\n                    resp = await response.json(content_type=None)\n                    assert \"url\" in resp, resp\n                    url_ = resp[\"url\"]\n                    drs_object.access_methods = [\n                        AccessMethod(access_url=url_, type=\"s3\")\n                    ]\n                    return drs_object\n\n                except ClientResponseError as e:\n                    drs_object.errors.append(str(e))\n                    return drs_object\n\n    async def get_object(self, object_id: str) -&gt; DrsObject:\n\"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object.\n\n        Args:\n            object_id (str): DRS URI\n\n        Raises:\n            Exception: The request was rejected by the server\n\n        Returns:\n            DownloadURL: The downloadable bundle ready for async download\n        \"\"\"\n        if not self.authorized:\n            await self.authorize()\n\n        headers = {\n            \"authorization\": \"Bearer \" + self.token,\n            \"content-type\": \"application/json\",\n        }\n\n        async with aiohttp.ClientSession(headers=headers) as session:\n            async with session.get(\n                url=f\"{self.endpoint}{self.drs_api}/{object_id.split(':')[-1]}\"\n            ) as response:\n                try:\n                    self.statistics.set_max_files_open()\n                    response.raise_for_status()\n                    resp = await response.json(content_type=None)\n\n                    assert resp[\"checksums\"][0][\"type\"] == \"md5\", resp\n                    md5_ = resp[\"checksums\"][0][\"checksum\"]\n                    size_ = resp[\"size\"]\n                    name_ = resp[\"name\"]\n                    return DrsObject(\n                        self_uri=object_id,\n                        size=size_,\n                        checksums=[Checksum(checksum=md5_, type=\"md5\")],\n                        id=object_id,\n                        name=name_,\n                        access_methods=[AccessMethod(access_url=\"\", type=\"gs\")],\n                    )\n                except ClientResponseError as e:\n                    return DrsObject(\n                        self_uri=object_id,\n                        id=object_id,\n                        checksums=[],\n                        size=0,\n                        name=None,\n                        errors=[str(e)],\n                    )\n</code></pre>"},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient.get_object","title":"<code>get_object(object_id)</code>  <code>async</code>","text":"<p>Sends a POST request for the signed URL, hash, and file size of a given DRS object.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>DRS URI</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>The request was rejected by the server</p> <p>Returns:</p> Name Type Description <code>DownloadURL</code> <code>DrsObject</code> <p>The downloadable bundle ready for async download</p> Source code in <code>drs_downloader/clients/gen3.py</code> <pre><code>async def get_object(self, object_id: str) -&gt; DrsObject:\n\"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object.\n\n    Args:\n        object_id (str): DRS URI\n\n    Raises:\n        Exception: The request was rejected by the server\n\n    Returns:\n        DownloadURL: The downloadable bundle ready for async download\n    \"\"\"\n    if not self.authorized:\n        await self.authorize()\n\n    headers = {\n        \"authorization\": \"Bearer \" + self.token,\n        \"content-type\": \"application/json\",\n    }\n\n    async with aiohttp.ClientSession(headers=headers) as session:\n        async with session.get(\n            url=f\"{self.endpoint}{self.drs_api}/{object_id.split(':')[-1]}\"\n        ) as response:\n            try:\n                self.statistics.set_max_files_open()\n                response.raise_for_status()\n                resp = await response.json(content_type=None)\n\n                assert resp[\"checksums\"][0][\"type\"] == \"md5\", resp\n                md5_ = resp[\"checksums\"][0][\"checksum\"]\n                size_ = resp[\"size\"]\n                name_ = resp[\"name\"]\n                return DrsObject(\n                    self_uri=object_id,\n                    size=size_,\n                    checksums=[Checksum(checksum=md5_, type=\"md5\")],\n                    id=object_id,\n                    name=name_,\n                    access_methods=[AccessMethod(access_url=\"\", type=\"gs\")],\n                )\n            except ClientResponseError as e:\n                return DrsObject(\n                    self_uri=object_id,\n                    id=object_id,\n                    checksums=[],\n                    size=0,\n                    name=None,\n                    errors=[str(e)],\n                )\n</code></pre>"},{"location":"reference/clients/gen3.html#drs_downloader.clients.gen3.Gen3DrsClient.sign_url","title":"<code>sign_url(drs_object)</code>  <code>async</code>","text":"<p>Call fence's /user/data/download/ endpoint.</p> Source code in <code>drs_downloader/clients/gen3.py</code> <pre><code>async def sign_url(self, drs_object: DrsObject) -&gt; DrsObject:\n\"\"\"Call fence's /user/data/download/ endpoint.\"\"\"\n\n    headers = {\n        \"authorization\": \"Bearer \" + self.token,\n        \"content-type\": \"application/json\",\n    }\n    async with aiohttp.ClientSession(headers=headers) as session:\n        async with session.get(\n            url=f\"{self.endpoint}/user/data/download/{drs_object.id.split(':')[-1]}\"\n        ) as response:\n            try:\n                self.statistics.set_max_files_open()\n                response.raise_for_status()\n                resp = await response.json(content_type=None)\n                assert \"url\" in resp, resp\n                url_ = resp[\"url\"]\n                drs_object.access_methods = [\n                    AccessMethod(access_url=url_, type=\"s3\")\n                ]\n                return drs_object\n\n            except ClientResponseError as e:\n                drs_object.errors.append(str(e))\n                return drs_object\n</code></pre>"},{"location":"reference/clients/mock.html","title":"mock","text":""},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient","title":"<code>MockDrsClient</code>","text":"<p>             Bases: <code>DrsClient</code></p> <p>Simulate responses from server.</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>class MockDrsClient(DrsClient):\n\"\"\"Simulate responses from server.\"\"\"\n\n    async def sign_url(self, drs_object: DrsObject, verbose: bool = False) -&gt; Optional[DrsObject]:\n\"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject\n\n        Args:\n            drs_object:\n\n        Returns:\n            populated DrsObject\n        \"\"\"\n        # simulate a failed signature\n        if drs_object.id == BAD_SIGNATURE:\n            return None\n\n        # here we sleep while the file is open and measure total files open\n        fp = tempfile.TemporaryFile()\n        sleep_duration = random.randint(1, 3)\n        await asyncio.sleep(delay=sleep_duration)\n        fp.write(b\"sign url\")\n        self.statistics.set_max_files_open()\n        fp.close()\n\n        # provide expected result, e.g. X-Signature\n        access_url = f\"{drs_object.self_uri}?X-Signature={uuid.uuid1()}\"\n        # place it in the right spot in the drs object\n        drs_object.access_methods.append(AccessMethod(access_url=access_url, type=\"gs\"))\n\n        return drs_object\n\n    async def download_part(\n        self, drs_object: DrsObject, start: int, size: int, destination_path: Path, verbose: bool = False\n    ) -&gt; Path:\n\"\"\"Actually download a part.\n\n        Args:\n            destination_path:\n            drs_object:\n            start:\n            size:\n\n        Returns:\n            full path to that part.\n        \"\"\"\n\n        # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\n\n        length_ = size - start + 1\n        # logger.info((drs_object.name, start, length_))\n        # logger.error(\"ERROR1 %s\",drs_object)\n\n        if BAD_ID in drs_object.self_uri:\n            logger.warning(f\"Mock bad id {drs_object.self_uri}\")\n            drs_object.errors = [\"Mock error BAD_ID\"]\n            return None\n\n        with open(Path(os.getcwd(), f\"{drs_object.name}.golden\"), \"rb\") as f:\n            f.seek(start)\n            data = f.read(length_)\n\n        (fd, name,) = tempfile.mkstemp(\n            prefix=f\"{drs_object.name}.{start}.{size}.\",\n            suffix=\".part\",\n            dir=str(destination_path),\n        )\n        with os.fdopen(fd, \"wb\") as fp:\n            sleep_duration = random.randint(1, 3)\n            await asyncio.sleep(delay=sleep_duration)\n            fp.write(data)\n            self.statistics.set_max_files_open()\n            fp.close()\n\n        return Path(name)\n\n    async def get_object(self, object_id: str, verbose: bool = False) -&gt; DrsObject:\n\"\"\"Fetch the object from repository DRS Service.\n\n        See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject.\n\n        Args:\n            object_id:\n\n        Returns:\n\n        \"\"\"\n        # \"\"\"Actually fetch the object.\n        #\n        # \"\"\"\n        fp = tempfile.TemporaryFile()\n        sleep_duration = random.randint(1, 3)\n        await asyncio.sleep(delay=sleep_duration)\n        fp.write(b\"get object\")\n        self.statistics.set_max_files_open()\n        fp.close()\n\n        id_ = str(uuid.uuid4())\n        name_ = f\"file-{id_}.txt\"\n\n        line = b\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\n\"  # noqa\n        line_len = len(line)\n        number_of_lines = int(random.randint(line_len, MAX_SIZE_OF_OBJECT) / line_len)\n        lines = line * number_of_lines\n        size_ = len(lines)\n\n        # write it for testing\n        destination_dir = Path(os.getcwd())\n        destination_dir.mkdir(parents=True, exist_ok=True)\n        with open(Path(f\"{destination_dir}/{name_}.golden\"), \"wb\") as f:\n            f.write(lines)\n\n        checksum = Checksum(hashlib.new(\"md5\", lines).hexdigest(), type=\"md5\")\n\n        # simulate an incorrect MD5\n        if object_id == BAD_MD5:\n            checksum = Checksum(hashlib.new(\"md5\", line).hexdigest(), type=\"md5\")\n\n        # simulate an incorrect size\n        if object_id == INCORRECT_SIZE:\n            size_ += 1000\n\n        return DrsObject(\n            self_uri=object_id,\n            size=size_,\n            # md5, etag, crc32c, trunc512, or sha1\n            checksums=[checksum],\n            id=id_,\n            name=name_,\n        )\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.download_part","title":"<code>download_part(drs_object, start, size, destination_path, verbose=False)</code>  <code>async</code>","text":"<p>Actually download a part.</p> <p>Parameters:</p> Name Type Description Default <code>destination_path</code> <code>Path</code> required <code>drs_object</code> <code>DrsObject</code> required <code>start</code> <code>int</code> required <code>size</code> <code>int</code> required <p>Returns:</p> Type Description <code>Path</code> <p>full path to that part.</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>async def download_part(\n    self, drs_object: DrsObject, start: int, size: int, destination_path: Path, verbose: bool = False\n) -&gt; Path:\n\"\"\"Actually download a part.\n\n    Args:\n        destination_path:\n        drs_object:\n        start:\n        size:\n\n    Returns:\n        full path to that part.\n    \"\"\"\n\n    # calculate actual part size from range see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\n\n    length_ = size - start + 1\n    # logger.info((drs_object.name, start, length_))\n    # logger.error(\"ERROR1 %s\",drs_object)\n\n    if BAD_ID in drs_object.self_uri:\n        logger.warning(f\"Mock bad id {drs_object.self_uri}\")\n        drs_object.errors = [\"Mock error BAD_ID\"]\n        return None\n\n    with open(Path(os.getcwd(), f\"{drs_object.name}.golden\"), \"rb\") as f:\n        f.seek(start)\n        data = f.read(length_)\n\n    (fd, name,) = tempfile.mkstemp(\n        prefix=f\"{drs_object.name}.{start}.{size}.\",\n        suffix=\".part\",\n        dir=str(destination_path),\n    )\n    with os.fdopen(fd, \"wb\") as fp:\n        sleep_duration = random.randint(1, 3)\n        await asyncio.sleep(delay=sleep_duration)\n        fp.write(data)\n        self.statistics.set_max_files_open()\n        fp.close()\n\n    return Path(name)\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.get_object","title":"<code>get_object(object_id, verbose=False)</code>  <code>async</code>","text":"<p>Fetch the object from repository DRS Service.</p> <p>See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> required <p>Returns:</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>async def get_object(self, object_id: str, verbose: bool = False) -&gt; DrsObject:\n\"\"\"Fetch the object from repository DRS Service.\n\n    See https://ga4gh.github.io/data-repository-service-schemas/preview/release/drs-1.0.0/docs/#_getobject.\n\n    Args:\n        object_id:\n\n    Returns:\n\n    \"\"\"\n    # \"\"\"Actually fetch the object.\n    #\n    # \"\"\"\n    fp = tempfile.TemporaryFile()\n    sleep_duration = random.randint(1, 3)\n    await asyncio.sleep(delay=sleep_duration)\n    fp.write(b\"get object\")\n    self.statistics.set_max_files_open()\n    fp.close()\n\n    id_ = str(uuid.uuid4())\n    name_ = f\"file-{id_}.txt\"\n\n    line = b\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\n\"  # noqa\n    line_len = len(line)\n    number_of_lines = int(random.randint(line_len, MAX_SIZE_OF_OBJECT) / line_len)\n    lines = line * number_of_lines\n    size_ = len(lines)\n\n    # write it for testing\n    destination_dir = Path(os.getcwd())\n    destination_dir.mkdir(parents=True, exist_ok=True)\n    with open(Path(f\"{destination_dir}/{name_}.golden\"), \"wb\") as f:\n        f.write(lines)\n\n    checksum = Checksum(hashlib.new(\"md5\", lines).hexdigest(), type=\"md5\")\n\n    # simulate an incorrect MD5\n    if object_id == BAD_MD5:\n        checksum = Checksum(hashlib.new(\"md5\", line).hexdigest(), type=\"md5\")\n\n    # simulate an incorrect size\n    if object_id == INCORRECT_SIZE:\n        size_ += 1000\n\n    return DrsObject(\n        self_uri=object_id,\n        size=size_,\n        # md5, etag, crc32c, trunc512, or sha1\n        checksums=[checksum],\n        id=id_,\n        name=name_,\n    )\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.MockDrsClient.sign_url","title":"<code>sign_url(drs_object, verbose=False)</code>  <code>async</code>","text":"<p>Simulate url signing by waiting 1-3 seconds, return populated DrsObject</p> <p>Parameters:</p> Name Type Description Default <code>drs_object</code> <code>DrsObject</code> required <p>Returns:</p> Type Description <code>Optional[DrsObject]</code> <p>populated DrsObject</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>async def sign_url(self, drs_object: DrsObject, verbose: bool = False) -&gt; Optional[DrsObject]:\n\"\"\"Simulate url signing by waiting 1-3 seconds, return populated DrsObject\n\n    Args:\n        drs_object:\n\n    Returns:\n        populated DrsObject\n    \"\"\"\n    # simulate a failed signature\n    if drs_object.id == BAD_SIGNATURE:\n        return None\n\n    # here we sleep while the file is open and measure total files open\n    fp = tempfile.TemporaryFile()\n    sleep_duration = random.randint(1, 3)\n    await asyncio.sleep(delay=sleep_duration)\n    fp.write(b\"sign url\")\n    self.statistics.set_max_files_open()\n    fp.close()\n\n    # provide expected result, e.g. X-Signature\n    access_url = f\"{drs_object.self_uri}?X-Signature={uuid.uuid1()}\"\n    # place it in the right spot in the drs object\n    drs_object.access_methods.append(AccessMethod(access_url=access_url, type=\"gs\"))\n\n    return drs_object\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_all_ok","title":"<code>manifest_all_ok(number_of_object_ids)</code>","text":"<p>Generate a test manifest, a tsv file with valid drs identifiers.</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>def manifest_all_ok(number_of_object_ids):\n\"\"\"Generate a test manifest, a tsv file with valid drs identifiers.\"\"\"\n    ids_from_manifest = [str(uuid.uuid4()) for _ in range(number_of_object_ids)]\n    tsv_file = tempfile.NamedTemporaryFile(delete=False, mode=\"w\")\n    tsv_file.write(\"ga4gh_drs_uri\\n\")\n    for id_ in ids_from_manifest:\n        tsv_file.write(f\"drs://{id_}\\n\")\n    tsv_file.close()\n    return tsv_file\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_bad_file_size","title":"<code>manifest_bad_file_size()</code>","text":"<p>Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>def manifest_bad_file_size():\n\"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\"\n    ids_from_manifest = [\n        \"drs://\" + str(uuid.uuid4()),\n        INCORRECT_SIZE,\n        \"drs://\" + str(uuid.uuid4()),\n    ]\n    tsv_file = tempfile.NamedTemporaryFile(delete=False, mode=\"w\")\n    tsv_file.write(\"ga4gh_drs_uri\\n\")\n    for id_ in ids_from_manifest:\n        tsv_file.write(f\"{id_}\\n\")\n    tsv_file.close()\n    return tsv_file\n</code></pre>"},{"location":"reference/clients/mock.html#drs_downloader.clients.mock.manifest_bad_id_for_download","title":"<code>manifest_bad_id_for_download()</code>","text":"<p>Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.</p> Source code in <code>drs_downloader/clients/mock.py</code> <pre><code>def manifest_bad_id_for_download():\n\"\"\"Generate a test manifest, a tsv file with 2 valid drs identifiers and one that will create an incorrect file.\"\"\"\n    ids_from_manifest = [\n        \"drs://\" + str(uuid.uuid4()),\n        \"drs://\" + str(uuid.uuid4()),\n        BAD_ID,\n        \"drs://\" + str(uuid.uuid4()),\n    ]\n    tsv_file = tempfile.NamedTemporaryFile(delete=False, mode=\"w\")\n    tsv_file.write(\"ga4gh_drs_uri\\n\")\n    for id_ in ids_from_manifest:\n        tsv_file.write(f\"{id_}\\n\")\n    tsv_file.close()\n    return tsv_file\n</code></pre>"},{"location":"reference/clients/terra.html","title":"terra","text":""},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient","title":"<code>TerraDrsClient</code>","text":"<p>             Bases: <code>DrsClient</code></p> <p>Calls the terra DRS server.</p> Source code in <code>drs_downloader/clients/terra.py</code> <pre><code>class TerraDrsClient(DrsClient):\n\"\"\"\n    Calls the terra DRS server.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.endpoint = (\n            \"https://us-central1-broad-dsde-prod.cloudfunctions.net/martha_v3\"\n        )\n        self.token = None\n\n    @dataclass\n    class GcloudInfo(object):\n        account: str\n        project: str\n\n    async def _get_auth_token(self) -&gt; str:\n\"\"\"Get Google Cloud authentication token.\n        User must run 'gcloud auth login' from the shell before starting this script.\n\n        Returns:\n            str: auth token\n            see https://github.com/DataBiosphere/terra-notebook-utils/blob/b53bb8656d\n            502ecbdbfe9c5edde3fa25bd90bbf8/terra_notebook_utils/gs.py#L25-L42\n\n        \"\"\"\n\n        creds, projects = google.auth.default()\n\n        creds.refresh(google.auth.transport.requests.Request())\n\n        token = creds.token\n\n        assert token, \"No token retrieved.\"\n        logger.info(\"gcloud token successfully fetched\")\n        return creds\n\n    async def download_part(\n        self, drs_object: DrsObject, start: int, size: int, destination_path: Path, verbose: bool = False\n    ) -&gt; Optional[Path]:\n        tries = 0\n        while True:\n            try:\n                headers = {\"Range\": f\"bytes={start}-{size}\"}\n                file_name = destination_path / f\"{drs_object.name}.{start}.{size}.part\"\n                context = ssl.create_default_context(cafile=certifi.where())\n                async with aiohttp.ClientSession(headers=headers) as session:\n                    async with session.get(\n                        drs_object.access_methods[0].access_url, ssl=context\n                    ) as request:\n                        if request.status &gt; 399:\n                            text = await request.content.read()\n\n                        request.raise_for_status()\n\n                        file = await aiofiles.open(file_name, \"wb\")\n                        self.statistics.set_max_files_open()\n                        async for data in request.content.iter_any():  # uses less memory\n                            await file.write(data)\n                        await file.close()\n                        return Path(file_name)\n\n            except aiohttp.ClientResponseError as f:\n                tries += 1\n                if \"The provided token has expired\" in str(text):\n                    if verbose:\n                        logger.info(f\"Error Text Body {str(text)}\")\n                    drs_object.errors.append(f\"RECOVERABLE in AIOHTTP {str(f)}\")\n                    return None\n\n                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                if tries &gt; 2:\n                    if verbose:\n                        logger.info(f\"Error Text Body {str(text)}\")\n                        return None\n\n            except Exception as e:\n                tries += 1\n                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                if tries &gt; 2:\n                    if verbose:\n                        logger.info(f\"Miscellaneous Error {str(text)}\")\n                    drs_object.errors.append(f\"NONRECOVERABLE ERROR {str(e)}\")\n                    return None\n\n    async def sign_url(self, drs_object: DrsObject, verbose: bool) -&gt; DrsObject:\n\"\"\"No-op.  terra returns a signed url in `get_object`\"\"\"\n\n        assert isinstance(drs_object, DrsObject), \"A DrsObject should be passed\"\n\n        if (self.token is None or (self.token.expired and self.token.expiry is not None)):\n            if verbose:\n                logger.info(\"fetching new token\")\n            self.token = await self._get_auth_token()\n\n        if verbose:\n            logger.info(f\"status of token expiration {self.token.expiry}\")\n\n        data = {\"url\": drs_object.id, \"fields\": [\"accessUrl\"]}\n        headers = {\n            \"authorization\": \"Bearer \" + self.token.token,\n            \"content-type\": \"application/json\",\n        }\n        tries = 0\n        context = ssl.create_default_context(cafile=certifi.where())\n        async with aiohttp.ClientSession(headers=headers) as session:\n            while (\n                True\n            ):  # This is here so that URL signing errors are caught they are rare, but I did capture one\n                try:\n                    async with session.post(url=self.endpoint, json=data, ssl=context) as response:\n                        while (True):\n                            try:\n                                self.statistics.set_max_files_open()\n\n                                # these lines produced an error saying that the content.read() had already closed\n                                if response.status &gt; 399:\n                                    text = await response.content.read()\n\n                                response.raise_for_status()\n                                resp = await response.json(content_type=None)\n                                assert \"accessUrl\" in resp, resp\n                                if resp[\"accessUrl\"] is None:\n                                    account_command = \"gcloud config get-value account\"\n                                    cmd = account_command.split(\" \")\n                                    account = subprocess.check_output(cmd).decode(\"ascii\")\n                                    raise Exception(\n                                        f\"A valid URL was not returned from the server. \\\n                                        Please check the access for {account}\\n{resp}\"\n                                    )\n                                url_ = resp[\"accessUrl\"][\"url\"]\n                                type = \"none\"\n                                if \"storage.googleapis.com\" in url_:\n                                    type = \"gs\"\n\n                                drs_object.access_methods = [\n                                    AccessMethod(access_url=url_, type=type)\n                                ]\n                                return drs_object\n                            except ClientResponseError as e:\n                                tries += 1\n                                if self.token.expired and self.token.expiry is not None:\n                                    self.token = await self._get_auth_token()\n                                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                                if tries &gt; 2:\n                                    if verbose:\n                                        logger.error(f\"value of text error  {str(text)}\")\n                                        logger.error(f\"A file has failed the signing process, specifically {str(e)}\")\n                                        if \"401\" in str(e):\n                                            drs_object.errors.append(f\"RECOVERABLE in AIOHTTP {str(e)}\")\n\n                                    return DrsObject(\n                                        self_uri=\"\",\n                                        id=\"\",\n                                        checksums=[],\n                                        size=0,\n                                        name=None,\n                                        errors=[f\"error: {str(text)}\"],\n                                    )\n\n                except ClientConnectorError as e:\n                    tries += 1\n                    if self.token.expired and self.token.expiry is not None:\n                        self.token = await self._get_auth_token()\n                    time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                    if tries &gt; 2:\n                        drs_object.errors.append(str(e))\n                        if verbose:\n                            logger.error(f\"retry failed in sign_url function. Exiting with error status: {str(e)}\")\n                            return DrsObject(\n                                self_uri=\"\",\n                                id=\"\",\n                                checksums=[],\n                                size=0,\n                                name=None,\n                                errors=[f\"error: {str(text)}\"],\n                            )\n\n    async def get_object(self, object_id: str, verbose: bool = False) -&gt; DrsObject:\n\"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object.\n\n        Args:\n            object_id (str): DRS URI\n\n        Raises:\n            Exception: The request was rejected by the server\n\n        Returns:\n            DownloadURL: The downloadable bundle ready for async download\n        \"\"\"\n\n        if (self.token is None or (self.token.expired and self.token.expiry is not None)):\n            if verbose:\n                logger.info(\"fetching new token\")\n            self.token = await self._get_auth_token()\n\n        if verbose:\n            logger.info(f\"status of token expiration {self.token.expiry}\")\n\n        data = {\"url\": object_id, \"fields\": [\"fileName\", \"size\", \"hashes\"]}\n        headers = {\n            \"authorization\": \"Bearer \" + self.token.token,\n            \"content-type\": \"application/json\",\n        }\n        tries = 0\n\n        context = ssl.create_default_context(cafile=certifi.where())\n        async with aiohttp.ClientSession(headers=headers) as session:\n            while True:  # this is here for the somewhat more common Martha disconnects.\n                try:\n                    async with session.post(url=self.endpoint, json=data, ssl=context) as response:\n                        while True:\n                            try:\n                                self.statistics.set_max_files_open()\n                                if response.status &gt; 399:\n                                    text = await response.content.read()\n\n                                response.raise_for_status()\n                                resp = await response.json(content_type=None)\n                                md5_ = resp[\"hashes\"][\"md5\"]\n                                size_ = resp[\"size\"]\n                                name_ = resp[\"fileName\"]\n                                return DrsObject(\n                                    self_uri=object_id,\n                                    size=size_,\n                                    checksums=[Checksum(checksum=md5_, type=\"md5\")],\n                                    id=object_id,\n                                    name=name_,\n                                )\n                            except ClientResponseError as e:\n                                tries += 1\n                                if verbose:\n                                    logger.info(f\"Client Response Error {str(text)}\")\n                                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                                if tries &gt; 2:\n                                    if verbose:\n                                        logger.error(f\"retry failed in get_object function. \\\n                                                     Exiting with error status: {str(e)}\")\n                                    return DrsObject(\n                                        self_uri=object_id,\n                                        id=object_id,\n                                        checksums=[],\n                                        size=0,\n                                        name=None,\n                                        errors=[str(e)],\n                                    )\n                except ClientConnectorError as e:\n                    tries += 1\n                    if verbose:\n                        logger.info(f\"ClientConnectorError: {str(e)} while fetching object information\")\n                    time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                    if tries &gt; 2:\n                        if verbose:\n                            logger.error(f\"value of text error {str(text)}\")\n                            logger.error(f\"retry failed in get_object function. Exiting with error status: {str(e)}\")\n                        return DrsObject(\n                            self_uri=object_id,\n                            id=object_id,\n                            checksums=[],\n                            size=0,\n                            name=None,\n                            errors=[str(e)],\n                        )\n</code></pre>"},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient.get_object","title":"<code>get_object(object_id, verbose=False)</code>  <code>async</code>","text":"<p>Sends a POST request for the signed URL, hash, and file size of a given DRS object.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>DRS URI</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>The request was rejected by the server</p> <p>Returns:</p> Name Type Description <code>DownloadURL</code> <code>DrsObject</code> <p>The downloadable bundle ready for async download</p> Source code in <code>drs_downloader/clients/terra.py</code> <pre><code>async def get_object(self, object_id: str, verbose: bool = False) -&gt; DrsObject:\n\"\"\"Sends a POST request for the signed URL, hash, and file size of a given DRS object.\n\n    Args:\n        object_id (str): DRS URI\n\n    Raises:\n        Exception: The request was rejected by the server\n\n    Returns:\n        DownloadURL: The downloadable bundle ready for async download\n    \"\"\"\n\n    if (self.token is None or (self.token.expired and self.token.expiry is not None)):\n        if verbose:\n            logger.info(\"fetching new token\")\n        self.token = await self._get_auth_token()\n\n    if verbose:\n        logger.info(f\"status of token expiration {self.token.expiry}\")\n\n    data = {\"url\": object_id, \"fields\": [\"fileName\", \"size\", \"hashes\"]}\n    headers = {\n        \"authorization\": \"Bearer \" + self.token.token,\n        \"content-type\": \"application/json\",\n    }\n    tries = 0\n\n    context = ssl.create_default_context(cafile=certifi.where())\n    async with aiohttp.ClientSession(headers=headers) as session:\n        while True:  # this is here for the somewhat more common Martha disconnects.\n            try:\n                async with session.post(url=self.endpoint, json=data, ssl=context) as response:\n                    while True:\n                        try:\n                            self.statistics.set_max_files_open()\n                            if response.status &gt; 399:\n                                text = await response.content.read()\n\n                            response.raise_for_status()\n                            resp = await response.json(content_type=None)\n                            md5_ = resp[\"hashes\"][\"md5\"]\n                            size_ = resp[\"size\"]\n                            name_ = resp[\"fileName\"]\n                            return DrsObject(\n                                self_uri=object_id,\n                                size=size_,\n                                checksums=[Checksum(checksum=md5_, type=\"md5\")],\n                                id=object_id,\n                                name=name_,\n                            )\n                        except ClientResponseError as e:\n                            tries += 1\n                            if verbose:\n                                logger.info(f\"Client Response Error {str(text)}\")\n                            time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                            if tries &gt; 2:\n                                if verbose:\n                                    logger.error(f\"retry failed in get_object function. \\\n                                                 Exiting with error status: {str(e)}\")\n                                return DrsObject(\n                                    self_uri=object_id,\n                                    id=object_id,\n                                    checksums=[],\n                                    size=0,\n                                    name=None,\n                                    errors=[str(e)],\n                                )\n            except ClientConnectorError as e:\n                tries += 1\n                if verbose:\n                    logger.info(f\"ClientConnectorError: {str(e)} while fetching object information\")\n                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                if tries &gt; 2:\n                    if verbose:\n                        logger.error(f\"value of text error {str(text)}\")\n                        logger.error(f\"retry failed in get_object function. Exiting with error status: {str(e)}\")\n                    return DrsObject(\n                        self_uri=object_id,\n                        id=object_id,\n                        checksums=[],\n                        size=0,\n                        name=None,\n                        errors=[str(e)],\n                    )\n</code></pre>"},{"location":"reference/clients/terra.html#drs_downloader.clients.terra.TerraDrsClient.sign_url","title":"<code>sign_url(drs_object, verbose)</code>  <code>async</code>","text":"<p>No-op.  terra returns a signed url in <code>get_object</code></p> Source code in <code>drs_downloader/clients/terra.py</code> <pre><code>async def sign_url(self, drs_object: DrsObject, verbose: bool) -&gt; DrsObject:\n\"\"\"No-op.  terra returns a signed url in `get_object`\"\"\"\n\n    assert isinstance(drs_object, DrsObject), \"A DrsObject should be passed\"\n\n    if (self.token is None or (self.token.expired and self.token.expiry is not None)):\n        if verbose:\n            logger.info(\"fetching new token\")\n        self.token = await self._get_auth_token()\n\n    if verbose:\n        logger.info(f\"status of token expiration {self.token.expiry}\")\n\n    data = {\"url\": drs_object.id, \"fields\": [\"accessUrl\"]}\n    headers = {\n        \"authorization\": \"Bearer \" + self.token.token,\n        \"content-type\": \"application/json\",\n    }\n    tries = 0\n    context = ssl.create_default_context(cafile=certifi.where())\n    async with aiohttp.ClientSession(headers=headers) as session:\n        while (\n            True\n        ):  # This is here so that URL signing errors are caught they are rare, but I did capture one\n            try:\n                async with session.post(url=self.endpoint, json=data, ssl=context) as response:\n                    while (True):\n                        try:\n                            self.statistics.set_max_files_open()\n\n                            # these lines produced an error saying that the content.read() had already closed\n                            if response.status &gt; 399:\n                                text = await response.content.read()\n\n                            response.raise_for_status()\n                            resp = await response.json(content_type=None)\n                            assert \"accessUrl\" in resp, resp\n                            if resp[\"accessUrl\"] is None:\n                                account_command = \"gcloud config get-value account\"\n                                cmd = account_command.split(\" \")\n                                account = subprocess.check_output(cmd).decode(\"ascii\")\n                                raise Exception(\n                                    f\"A valid URL was not returned from the server. \\\n                                    Please check the access for {account}\\n{resp}\"\n                                )\n                            url_ = resp[\"accessUrl\"][\"url\"]\n                            type = \"none\"\n                            if \"storage.googleapis.com\" in url_:\n                                type = \"gs\"\n\n                            drs_object.access_methods = [\n                                AccessMethod(access_url=url_, type=type)\n                            ]\n                            return drs_object\n                        except ClientResponseError as e:\n                            tries += 1\n                            if self.token.expired and self.token.expiry is not None:\n                                self.token = await self._get_auth_token()\n                            time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                            if tries &gt; 2:\n                                if verbose:\n                                    logger.error(f\"value of text error  {str(text)}\")\n                                    logger.error(f\"A file has failed the signing process, specifically {str(e)}\")\n                                    if \"401\" in str(e):\n                                        drs_object.errors.append(f\"RECOVERABLE in AIOHTTP {str(e)}\")\n\n                                return DrsObject(\n                                    self_uri=\"\",\n                                    id=\"\",\n                                    checksums=[],\n                                    size=0,\n                                    name=None,\n                                    errors=[f\"error: {str(text)}\"],\n                                )\n\n            except ClientConnectorError as e:\n                tries += 1\n                if self.token.expired and self.token.expiry is not None:\n                    self.token = await self._get_auth_token()\n                time.sleep((random.randint(0, 1000) / 1000) + 2**tries)\n                if tries &gt; 2:\n                    drs_object.errors.append(str(e))\n                    if verbose:\n                        logger.error(f\"retry failed in sign_url function. Exiting with error status: {str(e)}\")\n                        return DrsObject(\n                            self_uri=\"\",\n                            id=\"\",\n                            checksums=[],\n                            size=0,\n                            name=None,\n                            errors=[f\"error: {str(text)}\"],\n                        )\n</code></pre>"}]}